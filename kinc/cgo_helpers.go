//  Copyright (c) 2017 the Kore Development Team
// This software is provided 'as-is', without any express or implied warranty. In no event will the authors be held liable for any damages arising from the use of this software.
// Permission is granted to anyone to use this software for any purpose, including commercial applications, and to alter it and redistribute it freely, subject to the following restrictions:
// 1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

// WARNING: This file has automatically been generated
// Code generated by https://git.io/c-for-go. DO NOT EDIT.

package kinc

/*
#cgo CFLAGS: -I.
#cgo CFLAGS: -I${SRCDIR}/../Sources
#cgo darwin CFLAGS: -I${SRCDIR}/../Backends/System/Apple/Sources -I${SRCDIR}/../Backends/System/POSIX/Sources -DKORE_MACOS=1 -DKORE_POSIX=1
#cgo linux CFLAGS: -I${SRCDIR}/../Backends/System/Linux/Sources -I${SRCDIR}/../Backends/System/POSIX/Sources -DKORE_LINUX=1 -DKORE_POSIX=1
#cgo darwin LDFLAGS: -framework Foundation -framework AVFoundation -framework IOKit -framework Cocoa -framework AppKit -framework CoreAudio -framework CoreMedia -framework CoreVideo
#cgo linux LDFLAGS: -lasound -ldl
#cgo darwin metal CFLAGS: -I${SRCDIR}/../Backends/Graphics4/OpenGL/Sources -I${SRCDIR}/../Backends/Graphics5/Metal/Sources -I${SRCDIR}/../Backends/Graphics4/G4onG5/Sources -DKORE_G4=1 -DKORE_G5=1 -DKORE_G4ONG5 -DKORE_METAL=1
#cgo darwin metal LDFLAGS: -framework Metal -framework MetalKit
#include "kinc/pch.h"
#include "kinc/window.h"
#include "kinc/display.h"
#include "kinc/color.h"
#include "kinc/image.h"
#include "kinc/system.h"
#include "kinc/audio1/audio.h"
#include "kinc/audio2/audio.h"
#include "kinc/graphics4/graphics.h"
#include "kinc/graphics4/constantlocation.h"
#include "kinc/graphics4/indexbuffer.h"
#include "kinc/graphics4/pipeline.h"
#include "kinc/graphics4/rendertarget.h"
#include "kinc/graphics4/shader.h"
#include "kinc/graphics4/texture.h"
#include "kinc/graphics4/texturearray.h"
#include "kinc/graphics4/textureunit.h"
#include "kinc/graphics4/vertexbuffer.h"
#include "kinc/graphics4/vertexstructure.h"
#include "kinc/graphics1/graphics.h"
#include "kinc/compute/compute.h"
#include "kinc/input/acceleration.h"
#include "kinc/input/gamepad.h"
#include "kinc/input/keyboard.h"
#include "kinc/input/mouse.h"
#include "kinc/input/pen.h"
#include "kinc/input/rotation.h"
#include "kinc/input/surface.h"
#include "kinc/math/core.h"
#include "kinc/math/matrix.h"
#include "kinc/math/random.h"
#include "kinc/math/vector.h"
#include "kinc/simd/float32x4.h"
#include "kinc/bridge.h"
#include <stdlib.h>
#include "cgo_helpers.h"
*/
import "C"
import (
	"fmt"
	"runtime"
	"sync"
	"unsafe"
)

// cgoAllocMap stores pointers to C allocated memory for future reference.
type cgoAllocMap struct {
	mux sync.RWMutex
	m   map[unsafe.Pointer]struct{}
}

var cgoAllocsUnknown = new(cgoAllocMap)

func (a *cgoAllocMap) Add(ptr unsafe.Pointer) {
	a.mux.Lock()
	if a.m == nil {
		a.m = make(map[unsafe.Pointer]struct{})
	}
	a.m[ptr] = struct{}{}
	a.mux.Unlock()
}

func (a *cgoAllocMap) IsEmpty() bool {
	a.mux.RLock()
	isEmpty := len(a.m) == 0
	a.mux.RUnlock()
	return isEmpty
}

func (a *cgoAllocMap) Borrow(b *cgoAllocMap) {
	if b == nil || b.IsEmpty() {
		return
	}
	b.mux.Lock()
	a.mux.Lock()
	for ptr := range b.m {
		if a.m == nil {
			a.m = make(map[unsafe.Pointer]struct{})
		}
		a.m[ptr] = struct{}{}
		delete(b.m, ptr)
	}
	a.mux.Unlock()
	b.mux.Unlock()
}

func (a *cgoAllocMap) Free() {
	a.mux.Lock()
	for ptr := range a.m {
		C.free(ptr)
		delete(a.m, ptr)
	}
	a.mux.Unlock()
}

// allocKinc_g4_texture_arrayMemory allocates memory for type C.kinc_g4_texture_array_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocKinc_g4_texture_arrayMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfKinc_g4_texture_arrayValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfKinc_g4_texture_arrayValue = unsafe.Sizeof([1]C.kinc_g4_texture_array_t{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *kinc_g4_texture_array) Ref() *C.kinc_g4_texture_array_t {
	if x == nil {
		return nil
	}
	return x.ref364d6bfc
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *kinc_g4_texture_array) Free() {
	if x != nil && x.allocs364d6bfc != nil {
		x.allocs364d6bfc.(*cgoAllocMap).Free()
		x.ref364d6bfc = nil
	}
}

// Newkinc_g4_texture_arrayRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func Newkinc_g4_texture_arrayRef(ref unsafe.Pointer) *kinc_g4_texture_array {
	if ref == nil {
		return nil
	}
	obj := new(kinc_g4_texture_array)
	obj.ref364d6bfc = (*C.kinc_g4_texture_array_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *kinc_g4_texture_array) PassRef() (*C.kinc_g4_texture_array_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref364d6bfc != nil {
		return x.ref364d6bfc, nil
	}
	mem364d6bfc := allocKinc_g4_texture_arrayMemory(1)
	ref364d6bfc := (*C.kinc_g4_texture_array_t)(mem364d6bfc)
	allocs364d6bfc := new(cgoAllocMap)
	allocs364d6bfc.Add(mem364d6bfc)

	var cimpl_allocs *cgoAllocMap
	ref364d6bfc.impl, cimpl_allocs = x.impl.PassValue()
	allocs364d6bfc.Borrow(cimpl_allocs)

	x.ref364d6bfc = ref364d6bfc
	x.allocs364d6bfc = allocs364d6bfc
	return ref364d6bfc, allocs364d6bfc

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x kinc_g4_texture_array) PassValue() (C.kinc_g4_texture_array_t, *cgoAllocMap) {
	if x.ref364d6bfc != nil {
		return *x.ref364d6bfc, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *kinc_g4_texture_array) Deref() {
	if x.ref364d6bfc == nil {
		return
	}
	x.impl = *Newkinc_g4_texture_array_implRef(unsafe.Pointer(&x.ref364d6bfc.impl))
}

// allocKinc_g4_vertex_elementMemory allocates memory for type C.kinc_g4_vertex_element_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocKinc_g4_vertex_elementMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfKinc_g4_vertex_elementValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfKinc_g4_vertex_elementValue = unsafe.Sizeof([1]C.kinc_g4_vertex_element_t{})

// unpackPCharString copies the data from Go string as *C.char.
func unpackPCharString(str string) (*C.char, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CString(str))
	allocs.Add(mem0)
	return (*C.char)(mem0), allocs
}

type stringHeader struct {
	Data unsafe.Pointer
	Len  int
}

// packPCharString creates a Go string backed by *C.char and avoids copying.
func packPCharString(p *C.char) (raw string) {
	if p != nil && *p != 0 {
		h := (*stringHeader)(unsafe.Pointer(&raw))
		h.Data = unsafe.Pointer(p)
		for *p != 0 {
			p = (*C.char)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + 1)) // p++
		}
		h.Len = int(uintptr(unsafe.Pointer(p)) - uintptr(h.Data))
	}
	return
}

// RawString reperesents a string backed by data on the C side.
type RawString string

// Copy returns a Go-managed copy of raw string.
func (raw RawString) Copy() string {
	if len(raw) == 0 {
		return ""
	}
	h := (*stringHeader)(unsafe.Pointer(&raw))
	return C.GoStringN((*C.char)(h.Data), C.int(h.Len))
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *kinc_g4_vertex_element) Ref() *C.kinc_g4_vertex_element_t {
	if x == nil {
		return nil
	}
	return x.refff632198
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *kinc_g4_vertex_element) Free() {
	if x != nil && x.allocsff632198 != nil {
		x.allocsff632198.(*cgoAllocMap).Free()
		x.refff632198 = nil
	}
}

// Newkinc_g4_vertex_elementRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func Newkinc_g4_vertex_elementRef(ref unsafe.Pointer) *kinc_g4_vertex_element {
	if ref == nil {
		return nil
	}
	obj := new(kinc_g4_vertex_element)
	obj.refff632198 = (*C.kinc_g4_vertex_element_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *kinc_g4_vertex_element) PassRef() (*C.kinc_g4_vertex_element_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refff632198 != nil {
		return x.refff632198, nil
	}
	memff632198 := allocKinc_g4_vertex_elementMemory(1)
	refff632198 := (*C.kinc_g4_vertex_element_t)(memff632198)
	allocsff632198 := new(cgoAllocMap)
	allocsff632198.Add(memff632198)

	var cname_allocs *cgoAllocMap
	refff632198.name, cname_allocs = unpackPCharString(x.name)
	allocsff632198.Borrow(cname_allocs)

	var cdata_allocs *cgoAllocMap
	refff632198.data, cdata_allocs = (C.kinc_g4_vertex_data_t)(x.data), cgoAllocsUnknown
	allocsff632198.Borrow(cdata_allocs)

	x.refff632198 = refff632198
	x.allocsff632198 = allocsff632198
	return refff632198, allocsff632198

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x kinc_g4_vertex_element) PassValue() (C.kinc_g4_vertex_element_t, *cgoAllocMap) {
	if x.refff632198 != nil {
		return *x.refff632198, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *kinc_g4_vertex_element) Deref() {
	if x.refff632198 == nil {
		return
	}
	x.name = packPCharString(x.refff632198.name)
	x.data = (kinc_g4_vertex_data)(x.refff632198.data)
}

// allocKinc_g4_vertex_structureMemory allocates memory for type C.kinc_g4_vertex_structure_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocKinc_g4_vertex_structureMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfKinc_g4_vertex_structureValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfKinc_g4_vertex_structureValue = unsafe.Sizeof([1]C.kinc_g4_vertex_structure_t{})

// allocA16Kinc_g4_vertex_elementMemory allocates memory for type [16]C.kinc_g4_vertex_element_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocA16Kinc_g4_vertex_elementMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfA16Kinc_g4_vertex_elementValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfA16Kinc_g4_vertex_elementValue = unsafe.Sizeof([1][16]C.kinc_g4_vertex_element_t{})

const sizeOfPtr = unsafe.Sizeof(&struct{}{})

// unpackA16Kinc_g4_vertex_element transforms a sliced Go data structure into plain C format.
func unpackA16Kinc_g4_vertex_element(x [16]kinc_g4_vertex_element) (unpacked [16]C.kinc_g4_vertex_element_t, allocs *cgoAllocMap) {
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := allocA16Kinc_g4_vertex_elementMemory(1)
	allocs.Add(mem0)
	v0 := (*[16]C.kinc_g4_vertex_element_t)(mem0)
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		__xv, allocs0 := x[i0].PassValue()
		v0[i0] = __xv
		allocs.Borrow(allocs0)
	}
	unpacked = *(*[16]C.kinc_g4_vertex_element_t)(mem0)
	return
}

type sliceHeader struct {
	Data unsafe.Pointer
	Len  int
	Cap  int
}

// packA16Kinc_g4_vertex_element reads sliced Go data structure out from plain C format.
func packA16Kinc_g4_vertex_element(v *[16]kinc_g4_vertex_element, ptr0 *[16]C.kinc_g4_vertex_element_t) {
	for i0 := range v {
		ptr1 := ptr0[i0]
		v[i0] = *Newkinc_g4_vertex_elementRef(unsafe.Pointer(&ptr1))
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *kinc_g4_vertex_structure) Ref() *C.kinc_g4_vertex_structure_t {
	if x == nil {
		return nil
	}
	return x.ref78e7400f
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *kinc_g4_vertex_structure) Free() {
	if x != nil && x.allocs78e7400f != nil {
		x.allocs78e7400f.(*cgoAllocMap).Free()
		x.ref78e7400f = nil
	}
}

// Newkinc_g4_vertex_structureRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func Newkinc_g4_vertex_structureRef(ref unsafe.Pointer) *kinc_g4_vertex_structure {
	if ref == nil {
		return nil
	}
	obj := new(kinc_g4_vertex_structure)
	obj.ref78e7400f = (*C.kinc_g4_vertex_structure_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *kinc_g4_vertex_structure) PassRef() (*C.kinc_g4_vertex_structure_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref78e7400f != nil {
		return x.ref78e7400f, nil
	}
	mem78e7400f := allocKinc_g4_vertex_structureMemory(1)
	ref78e7400f := (*C.kinc_g4_vertex_structure_t)(mem78e7400f)
	allocs78e7400f := new(cgoAllocMap)
	allocs78e7400f.Add(mem78e7400f)

	var celements_allocs *cgoAllocMap
	ref78e7400f.elements, celements_allocs = unpackA16Kinc_g4_vertex_element(x.elements)
	allocs78e7400f.Borrow(celements_allocs)

	var csize_allocs *cgoAllocMap
	ref78e7400f.size, csize_allocs = (C.int)(x.size), cgoAllocsUnknown
	allocs78e7400f.Borrow(csize_allocs)

	var cinstanced_allocs *cgoAllocMap
	ref78e7400f.instanced, cinstanced_allocs = (C._Bool)(x.instanced), cgoAllocsUnknown
	allocs78e7400f.Borrow(cinstanced_allocs)

	x.ref78e7400f = ref78e7400f
	x.allocs78e7400f = allocs78e7400f
	return ref78e7400f, allocs78e7400f

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x kinc_g4_vertex_structure) PassValue() (C.kinc_g4_vertex_structure_t, *cgoAllocMap) {
	if x.ref78e7400f != nil {
		return *x.ref78e7400f, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *kinc_g4_vertex_structure) Deref() {
	if x.ref78e7400f == nil {
		return
	}
	packA16Kinc_g4_vertex_element(&x.elements, (*[16]C.kinc_g4_vertex_element_t)(unsafe.Pointer(&x.ref78e7400f.elements)))
	x.size = (int32)(x.ref78e7400f.size)
	x.instanced = (bool)(x.ref78e7400f.instanced)
}

// allocKinc_g4_vertex_buffer_implMemory allocates memory for type C.kinc_g4_vertex_buffer_impl_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocKinc_g4_vertex_buffer_implMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfKinc_g4_vertex_buffer_implValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfKinc_g4_vertex_buffer_implValue = unsafe.Sizeof([1]C.kinc_g4_vertex_buffer_impl_t{})

// copyPFloatBytes copies the data from Go slice as *C.float.
func copyPFloatBytes(slice *sliceHeader) (*C.float, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfFloatValue) * slice.Len,
		Cap:  int(sizeOfFloatValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.float)(mem0), allocs
}

// allocFloatMemory allocates memory for type C.float in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFloatMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFloatValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfFloatValue = unsafe.Sizeof([1]C.float{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *kinc_g4_vertex_buffer_impl) Ref() *C.kinc_g4_vertex_buffer_impl_t {
	if x == nil {
		return nil
	}
	return x.ref97e99f8d
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *kinc_g4_vertex_buffer_impl) Free() {
	if x != nil && x.allocs97e99f8d != nil {
		x.allocs97e99f8d.(*cgoAllocMap).Free()
		x.ref97e99f8d = nil
	}
}

// Newkinc_g4_vertex_buffer_implRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func Newkinc_g4_vertex_buffer_implRef(ref unsafe.Pointer) *kinc_g4_vertex_buffer_impl {
	if ref == nil {
		return nil
	}
	obj := new(kinc_g4_vertex_buffer_impl)
	obj.ref97e99f8d = (*C.kinc_g4_vertex_buffer_impl_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *kinc_g4_vertex_buffer_impl) PassRef() (*C.kinc_g4_vertex_buffer_impl_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref97e99f8d != nil {
		return x.ref97e99f8d, nil
	}
	mem97e99f8d := allocKinc_g4_vertex_buffer_implMemory(1)
	ref97e99f8d := (*C.kinc_g4_vertex_buffer_impl_t)(mem97e99f8d)
	allocs97e99f8d := new(cgoAllocMap)
	allocs97e99f8d.Add(mem97e99f8d)

	var cdata_allocs *cgoAllocMap
	ref97e99f8d.data, cdata_allocs = copyPFloatBytes((*sliceHeader)(unsafe.Pointer(&x.data)))
	allocs97e99f8d.Borrow(cdata_allocs)

	var cmyCount_allocs *cgoAllocMap
	ref97e99f8d.myCount, cmyCount_allocs = (C.int)(x.mycount), cgoAllocsUnknown
	allocs97e99f8d.Borrow(cmyCount_allocs)

	var cmyStride_allocs *cgoAllocMap
	ref97e99f8d.myStride, cmyStride_allocs = (C.int)(x.mystride), cgoAllocsUnknown
	allocs97e99f8d.Borrow(cmyStride_allocs)

	var cbufferId_allocs *cgoAllocMap
	ref97e99f8d.bufferId, cbufferId_allocs = (C.uint)(x.bufferid), cgoAllocsUnknown
	allocs97e99f8d.Borrow(cbufferId_allocs)

	var cusage_allocs *cgoAllocMap
	ref97e99f8d.usage, cusage_allocs = (C.uint)(x.usage), cgoAllocsUnknown
	allocs97e99f8d.Borrow(cusage_allocs)

	var csectionStart_allocs *cgoAllocMap
	ref97e99f8d.sectionStart, csectionStart_allocs = (C.int)(x.sectionstart), cgoAllocsUnknown
	allocs97e99f8d.Borrow(csectionStart_allocs)

	var csectionSize_allocs *cgoAllocMap
	ref97e99f8d.sectionSize, csectionSize_allocs = (C.int)(x.sectionsize), cgoAllocsUnknown
	allocs97e99f8d.Borrow(csectionSize_allocs)

	var cstructure_allocs *cgoAllocMap
	ref97e99f8d.structure, cstructure_allocs = x.structure.PassValue()
	allocs97e99f8d.Borrow(cstructure_allocs)

	var cinstanceDataStepRate_allocs *cgoAllocMap
	ref97e99f8d.instanceDataStepRate, cinstanceDataStepRate_allocs = (C.int)(x.instancedatasteprate), cgoAllocsUnknown
	allocs97e99f8d.Borrow(cinstanceDataStepRate_allocs)

	var cinitialized_allocs *cgoAllocMap
	ref97e99f8d.initialized, cinitialized_allocs = (C._Bool)(x.initialized), cgoAllocsUnknown
	allocs97e99f8d.Borrow(cinitialized_allocs)

	x.ref97e99f8d = ref97e99f8d
	x.allocs97e99f8d = allocs97e99f8d
	return ref97e99f8d, allocs97e99f8d

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x kinc_g4_vertex_buffer_impl) PassValue() (C.kinc_g4_vertex_buffer_impl_t, *cgoAllocMap) {
	if x.ref97e99f8d != nil {
		return *x.ref97e99f8d, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *kinc_g4_vertex_buffer_impl) Deref() {
	if x.ref97e99f8d == nil {
		return
	}
	hxfc4425b := (*sliceHeader)(unsafe.Pointer(&x.data))
	hxfc4425b.Data = unsafe.Pointer(x.ref97e99f8d.data)
	hxfc4425b.Cap = 0x7fffffff
	// hxfc4425b.Len = ?

	x.mycount = (int32)(x.ref97e99f8d.myCount)
	x.mystride = (int32)(x.ref97e99f8d.myStride)
	x.bufferid = (uint32)(x.ref97e99f8d.bufferId)
	x.usage = (uint32)(x.ref97e99f8d.usage)
	x.sectionstart = (int32)(x.ref97e99f8d.sectionStart)
	x.sectionsize = (int32)(x.ref97e99f8d.sectionSize)
	x.structure = *Newkinc_g4_vertex_structureRef(unsafe.Pointer(&x.ref97e99f8d.structure))
	x.instancedatasteprate = (int32)(x.ref97e99f8d.instanceDataStepRate)
	x.initialized = (bool)(x.ref97e99f8d.initialized)
}

// allocKinc_g4_vertex_bufferMemory allocates memory for type C.kinc_g4_vertex_buffer_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocKinc_g4_vertex_bufferMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfKinc_g4_vertex_bufferValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfKinc_g4_vertex_bufferValue = unsafe.Sizeof([1]C.kinc_g4_vertex_buffer_t{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *kinc_g4_vertex_buffer) Ref() *C.kinc_g4_vertex_buffer_t {
	if x == nil {
		return nil
	}
	return x.refa516550d
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *kinc_g4_vertex_buffer) Free() {
	if x != nil && x.allocsa516550d != nil {
		x.allocsa516550d.(*cgoAllocMap).Free()
		x.refa516550d = nil
	}
}

// Newkinc_g4_vertex_bufferRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func Newkinc_g4_vertex_bufferRef(ref unsafe.Pointer) *kinc_g4_vertex_buffer {
	if ref == nil {
		return nil
	}
	obj := new(kinc_g4_vertex_buffer)
	obj.refa516550d = (*C.kinc_g4_vertex_buffer_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *kinc_g4_vertex_buffer) PassRef() (*C.kinc_g4_vertex_buffer_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refa516550d != nil {
		return x.refa516550d, nil
	}
	mema516550d := allocKinc_g4_vertex_bufferMemory(1)
	refa516550d := (*C.kinc_g4_vertex_buffer_t)(mema516550d)
	allocsa516550d := new(cgoAllocMap)
	allocsa516550d.Add(mema516550d)

	var cimpl_allocs *cgoAllocMap
	refa516550d.impl, cimpl_allocs = x.impl.PassValue()
	allocsa516550d.Borrow(cimpl_allocs)

	x.refa516550d = refa516550d
	x.allocsa516550d = allocsa516550d
	return refa516550d, allocsa516550d

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x kinc_g4_vertex_buffer) PassValue() (C.kinc_g4_vertex_buffer_t, *cgoAllocMap) {
	if x.refa516550d != nil {
		return *x.refa516550d, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *kinc_g4_vertex_buffer) Deref() {
	if x.refa516550d == nil {
		return
	}
	x.impl = *Newkinc_g4_vertex_buffer_implRef(unsafe.Pointer(&x.refa516550d.impl))
}

// allocKinc_compute_constant_locationMemory allocates memory for type C.kinc_compute_constant_location_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocKinc_compute_constant_locationMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfKinc_compute_constant_locationValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfKinc_compute_constant_locationValue = unsafe.Sizeof([1]C.kinc_compute_constant_location_t{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *kinc_compute_constant_location) Ref() *C.kinc_compute_constant_location_t {
	if x == nil {
		return nil
	}
	return x.ref2bcca015
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *kinc_compute_constant_location) Free() {
	if x != nil && x.allocs2bcca015 != nil {
		x.allocs2bcca015.(*cgoAllocMap).Free()
		x.ref2bcca015 = nil
	}
}

// Newkinc_compute_constant_locationRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func Newkinc_compute_constant_locationRef(ref unsafe.Pointer) *kinc_compute_constant_location {
	if ref == nil {
		return nil
	}
	obj := new(kinc_compute_constant_location)
	obj.ref2bcca015 = (*C.kinc_compute_constant_location_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *kinc_compute_constant_location) PassRef() (*C.kinc_compute_constant_location_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref2bcca015 != nil {
		return x.ref2bcca015, nil
	}
	mem2bcca015 := allocKinc_compute_constant_locationMemory(1)
	ref2bcca015 := (*C.kinc_compute_constant_location_t)(mem2bcca015)
	allocs2bcca015 := new(cgoAllocMap)
	allocs2bcca015.Add(mem2bcca015)

	var cimpl_allocs *cgoAllocMap
	ref2bcca015.impl, cimpl_allocs = x.impl.PassValue()
	allocs2bcca015.Borrow(cimpl_allocs)

	x.ref2bcca015 = ref2bcca015
	x.allocs2bcca015 = allocs2bcca015
	return ref2bcca015, allocs2bcca015

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x kinc_compute_constant_location) PassValue() (C.kinc_compute_constant_location_t, *cgoAllocMap) {
	if x.ref2bcca015 != nil {
		return *x.ref2bcca015, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *kinc_compute_constant_location) Deref() {
	if x.ref2bcca015 == nil {
		return
	}
	x.impl = *Newkinc_compute_constant_location_implRef(unsafe.Pointer(&x.ref2bcca015.impl))
}

// allocKinc_compute_texture_unitMemory allocates memory for type C.kinc_compute_texture_unit_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocKinc_compute_texture_unitMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfKinc_compute_texture_unitValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfKinc_compute_texture_unitValue = unsafe.Sizeof([1]C.kinc_compute_texture_unit_t{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *kinc_compute_texture_unit) Ref() *C.kinc_compute_texture_unit_t {
	if x == nil {
		return nil
	}
	return x.ref293ac4b0
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *kinc_compute_texture_unit) Free() {
	if x != nil && x.allocs293ac4b0 != nil {
		x.allocs293ac4b0.(*cgoAllocMap).Free()
		x.ref293ac4b0 = nil
	}
}

// Newkinc_compute_texture_unitRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func Newkinc_compute_texture_unitRef(ref unsafe.Pointer) *kinc_compute_texture_unit {
	if ref == nil {
		return nil
	}
	obj := new(kinc_compute_texture_unit)
	obj.ref293ac4b0 = (*C.kinc_compute_texture_unit_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *kinc_compute_texture_unit) PassRef() (*C.kinc_compute_texture_unit_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref293ac4b0 != nil {
		return x.ref293ac4b0, nil
	}
	mem293ac4b0 := allocKinc_compute_texture_unitMemory(1)
	ref293ac4b0 := (*C.kinc_compute_texture_unit_t)(mem293ac4b0)
	allocs293ac4b0 := new(cgoAllocMap)
	allocs293ac4b0.Add(mem293ac4b0)

	var cimpl_allocs *cgoAllocMap
	ref293ac4b0.impl, cimpl_allocs = x.impl.PassValue()
	allocs293ac4b0.Borrow(cimpl_allocs)

	x.ref293ac4b0 = ref293ac4b0
	x.allocs293ac4b0 = allocs293ac4b0
	return ref293ac4b0, allocs293ac4b0

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x kinc_compute_texture_unit) PassValue() (C.kinc_compute_texture_unit_t, *cgoAllocMap) {
	if x.ref293ac4b0 != nil {
		return *x.ref293ac4b0, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *kinc_compute_texture_unit) Deref() {
	if x.ref293ac4b0 == nil {
		return
	}
	x.impl = *Newkinc_compute_texture_unit_implRef(unsafe.Pointer(&x.ref293ac4b0.impl))
}

// allocKinc_compute_shaderMemory allocates memory for type C.kinc_compute_shader_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocKinc_compute_shaderMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfKinc_compute_shaderValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfKinc_compute_shaderValue = unsafe.Sizeof([1]C.kinc_compute_shader_t{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *kinc_compute_shader) Ref() *C.kinc_compute_shader_t {
	if x == nil {
		return nil
	}
	return x.ref3ed111d3
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *kinc_compute_shader) Free() {
	if x != nil && x.allocs3ed111d3 != nil {
		x.allocs3ed111d3.(*cgoAllocMap).Free()
		x.ref3ed111d3 = nil
	}
}

// Newkinc_compute_shaderRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func Newkinc_compute_shaderRef(ref unsafe.Pointer) *kinc_compute_shader {
	if ref == nil {
		return nil
	}
	obj := new(kinc_compute_shader)
	obj.ref3ed111d3 = (*C.kinc_compute_shader_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *kinc_compute_shader) PassRef() (*C.kinc_compute_shader_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref3ed111d3 != nil {
		return x.ref3ed111d3, nil
	}
	mem3ed111d3 := allocKinc_compute_shaderMemory(1)
	ref3ed111d3 := (*C.kinc_compute_shader_t)(mem3ed111d3)
	allocs3ed111d3 := new(cgoAllocMap)
	allocs3ed111d3.Add(mem3ed111d3)

	var cimpl_allocs *cgoAllocMap
	ref3ed111d3.impl, cimpl_allocs = x.impl.PassValue()
	allocs3ed111d3.Borrow(cimpl_allocs)

	x.ref3ed111d3 = ref3ed111d3
	x.allocs3ed111d3 = allocs3ed111d3
	return ref3ed111d3, allocs3ed111d3

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x kinc_compute_shader) PassValue() (C.kinc_compute_shader_t, *cgoAllocMap) {
	if x.ref3ed111d3 != nil {
		return *x.ref3ed111d3, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *kinc_compute_shader) Deref() {
	if x.ref3ed111d3 == nil {
		return
	}
	x.impl = *Newkinc_compute_shader_implRef(unsafe.Pointer(&x.ref3ed111d3.impl))
}

// copyPIntBytes copies the data from Go slice as *C.int.
func copyPIntBytes(slice *sliceHeader) (*C.int, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfIntValue) * slice.Len,
		Cap:  int(sizeOfIntValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.int)(mem0), allocs
}

// allocIntMemory allocates memory for type C.int in C.
// The caller is responsible for freeing the this memory via C.free.
func allocIntMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfIntValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfIntValue = unsafe.Sizeof([1]C.int{})

// allocKinc_imageMemory allocates memory for type C.kinc_image_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocKinc_imageMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfKinc_imageValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfKinc_imageValue = unsafe.Sizeof([1]C.kinc_image_t{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *kinc_g4_image) Ref() *C.kinc_image_t {
	if x == nil {
		return nil
	}
	return x.refa3fab79c
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *kinc_g4_image) Free() {
	if x != nil && x.allocsa3fab79c != nil {
		x.allocsa3fab79c.(*cgoAllocMap).Free()
		x.refa3fab79c = nil
	}
}

// Newkinc_g4_imageRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func Newkinc_g4_imageRef(ref unsafe.Pointer) *kinc_g4_image {
	if ref == nil {
		return nil
	}
	obj := new(kinc_g4_image)
	obj.refa3fab79c = (*C.kinc_image_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *kinc_g4_image) PassRef() (*C.kinc_image_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refa3fab79c != nil {
		return x.refa3fab79c, nil
	}
	mema3fab79c := allocKinc_imageMemory(1)
	refa3fab79c := (*C.kinc_image_t)(mema3fab79c)
	allocsa3fab79c := new(cgoAllocMap)
	allocsa3fab79c.Add(mema3fab79c)

	var cwidth_allocs *cgoAllocMap
	refa3fab79c.width, cwidth_allocs = (C.int)(x.width), cgoAllocsUnknown
	allocsa3fab79c.Borrow(cwidth_allocs)

	var cheight_allocs *cgoAllocMap
	refa3fab79c.height, cheight_allocs = (C.int)(x.height), cgoAllocsUnknown
	allocsa3fab79c.Borrow(cheight_allocs)

	var cdepth_allocs *cgoAllocMap
	refa3fab79c.depth, cdepth_allocs = (C.int)(x.depth), cgoAllocsUnknown
	allocsa3fab79c.Borrow(cdepth_allocs)

	var cformat_allocs *cgoAllocMap
	refa3fab79c.format, cformat_allocs = (C.kinc_image_format_t)(x.format), cgoAllocsUnknown
	allocsa3fab79c.Borrow(cformat_allocs)

	var cinternal_format_allocs *cgoAllocMap
	refa3fab79c.internal_format, cinternal_format_allocs = (C.uint)(x.internal_format), cgoAllocsUnknown
	allocsa3fab79c.Borrow(cinternal_format_allocs)

	var ccompression_allocs *cgoAllocMap
	refa3fab79c.compression, ccompression_allocs = (C.kinc_image_compression_t)(x.compression), cgoAllocsUnknown
	allocsa3fab79c.Borrow(ccompression_allocs)

	var cdata_allocs *cgoAllocMap
	refa3fab79c.data, cdata_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.data)), cgoAllocsUnknown
	allocsa3fab79c.Borrow(cdata_allocs)

	var cdata_size_allocs *cgoAllocMap
	refa3fab79c.data_size, cdata_size_allocs = (C.int)(x.data_size), cgoAllocsUnknown
	allocsa3fab79c.Borrow(cdata_size_allocs)

	x.refa3fab79c = refa3fab79c
	x.allocsa3fab79c = allocsa3fab79c
	return refa3fab79c, allocsa3fab79c

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x kinc_g4_image) PassValue() (C.kinc_image_t, *cgoAllocMap) {
	if x.refa3fab79c != nil {
		return *x.refa3fab79c, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *kinc_g4_image) Deref() {
	if x.refa3fab79c == nil {
		return
	}
	x.width = (int32)(x.refa3fab79c.width)
	x.height = (int32)(x.refa3fab79c.height)
	x.depth = (int32)(x.refa3fab79c.depth)
	x.format = (kinc_image_format)(x.refa3fab79c.format)
	x.internal_format = (uint32)(x.refa3fab79c.internal_format)
	x.compression = (kinc_image_compression)(x.refa3fab79c.compression)
	x.data = (unsafe.Pointer)(unsafe.Pointer(x.refa3fab79c.data))
	x.data_size = (int32)(x.refa3fab79c.data_size)
}

// allocKinc_g4_textureMemory allocates memory for type C.kinc_g4_texture_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocKinc_g4_textureMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfKinc_g4_textureValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfKinc_g4_textureValue = unsafe.Sizeof([1]C.kinc_g4_texture_t{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *kinc_g4_texture) Ref() *C.kinc_g4_texture_t {
	if x == nil {
		return nil
	}
	return x.refb8f4534c
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *kinc_g4_texture) Free() {
	if x != nil && x.allocsb8f4534c != nil {
		x.allocsb8f4534c.(*cgoAllocMap).Free()
		x.refb8f4534c = nil
	}
}

// Newkinc_g4_textureRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func Newkinc_g4_textureRef(ref unsafe.Pointer) *kinc_g4_texture {
	if ref == nil {
		return nil
	}
	obj := new(kinc_g4_texture)
	obj.refb8f4534c = (*C.kinc_g4_texture_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *kinc_g4_texture) PassRef() (*C.kinc_g4_texture_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refb8f4534c != nil {
		return x.refb8f4534c, nil
	}
	memb8f4534c := allocKinc_g4_textureMemory(1)
	refb8f4534c := (*C.kinc_g4_texture_t)(memb8f4534c)
	allocsb8f4534c := new(cgoAllocMap)
	allocsb8f4534c.Add(memb8f4534c)

	var ctex_width_allocs *cgoAllocMap
	refb8f4534c.tex_width, ctex_width_allocs = (C.int)(x.tex_width), cgoAllocsUnknown
	allocsb8f4534c.Borrow(ctex_width_allocs)

	var ctex_height_allocs *cgoAllocMap
	refb8f4534c.tex_height, ctex_height_allocs = (C.int)(x.tex_height), cgoAllocsUnknown
	allocsb8f4534c.Borrow(ctex_height_allocs)

	var ctex_depth_allocs *cgoAllocMap
	refb8f4534c.tex_depth, ctex_depth_allocs = (C.int)(x.tex_depth), cgoAllocsUnknown
	allocsb8f4534c.Borrow(ctex_depth_allocs)

	var cformat_allocs *cgoAllocMap
	refb8f4534c.format, cformat_allocs = (C.kinc_image_format_t)(x.format), cgoAllocsUnknown
	allocsb8f4534c.Borrow(cformat_allocs)

	var cimpl_allocs *cgoAllocMap
	refb8f4534c.impl, cimpl_allocs = x.impl.PassValue()
	allocsb8f4534c.Borrow(cimpl_allocs)

	x.refb8f4534c = refb8f4534c
	x.allocsb8f4534c = allocsb8f4534c
	return refb8f4534c, allocsb8f4534c

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x kinc_g4_texture) PassValue() (C.kinc_g4_texture_t, *cgoAllocMap) {
	if x.refb8f4534c != nil {
		return *x.refb8f4534c, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *kinc_g4_texture) Deref() {
	if x.refb8f4534c == nil {
		return
	}
	x.tex_width = (int32)(x.refb8f4534c.tex_width)
	x.tex_height = (int32)(x.refb8f4534c.tex_height)
	x.tex_depth = (int32)(x.refb8f4534c.tex_depth)
	x.format = (kinc_image_format)(x.refb8f4534c.format)
	x.impl = *Newkinc_g4_texture_implRef(unsafe.Pointer(&x.refb8f4534c.impl))
}

// allocKinc_displayMemory allocates memory for type C.kinc_display_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocKinc_displayMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfKinc_displayValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfKinc_displayValue = unsafe.Sizeof([1]C.kinc_display_t{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *kinc_display) Ref() *C.kinc_display_t {
	if x == nil {
		return nil
	}
	return x.ref2dc88e5b
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *kinc_display) Free() {
	if x != nil && x.allocs2dc88e5b != nil {
		x.allocs2dc88e5b.(*cgoAllocMap).Free()
		x.ref2dc88e5b = nil
	}
}

// Newkinc_displayRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func Newkinc_displayRef(ref unsafe.Pointer) *kinc_display {
	if ref == nil {
		return nil
	}
	obj := new(kinc_display)
	obj.ref2dc88e5b = (*C.kinc_display_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *kinc_display) PassRef() (*C.kinc_display_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref2dc88e5b != nil {
		return x.ref2dc88e5b, nil
	}
	mem2dc88e5b := allocKinc_displayMemory(1)
	ref2dc88e5b := (*C.kinc_display_t)(mem2dc88e5b)
	allocs2dc88e5b := new(cgoAllocMap)
	allocs2dc88e5b.Add(mem2dc88e5b)

	var cavailable_allocs *cgoAllocMap
	ref2dc88e5b.available, cavailable_allocs = (C._Bool)(x.available), cgoAllocsUnknown
	allocs2dc88e5b.Borrow(cavailable_allocs)

	var cx_allocs *cgoAllocMap
	ref2dc88e5b.x, cx_allocs = (C.int)(x.x), cgoAllocsUnknown
	allocs2dc88e5b.Borrow(cx_allocs)

	var cy_allocs *cgoAllocMap
	ref2dc88e5b.y, cy_allocs = (C.int)(x.y), cgoAllocsUnknown
	allocs2dc88e5b.Borrow(cy_allocs)

	var cwidth_allocs *cgoAllocMap
	ref2dc88e5b.width, cwidth_allocs = (C.int)(x.width), cgoAllocsUnknown
	allocs2dc88e5b.Borrow(cwidth_allocs)

	var cheight_allocs *cgoAllocMap
	ref2dc88e5b.height, cheight_allocs = (C.int)(x.height), cgoAllocsUnknown
	allocs2dc88e5b.Borrow(cheight_allocs)

	var cprimary_allocs *cgoAllocMap
	ref2dc88e5b.primary, cprimary_allocs = (C._Bool)(x.primary), cgoAllocsUnknown
	allocs2dc88e5b.Borrow(cprimary_allocs)

	var cnumber_allocs *cgoAllocMap
	ref2dc88e5b.number, cnumber_allocs = (C.int)(x.number), cgoAllocsUnknown
	allocs2dc88e5b.Borrow(cnumber_allocs)

	x.ref2dc88e5b = ref2dc88e5b
	x.allocs2dc88e5b = allocs2dc88e5b
	return ref2dc88e5b, allocs2dc88e5b

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x kinc_display) PassValue() (C.kinc_display_t, *cgoAllocMap) {
	if x.ref2dc88e5b != nil {
		return *x.ref2dc88e5b, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *kinc_display) Deref() {
	if x.ref2dc88e5b == nil {
		return
	}
	x.available = (bool)(x.ref2dc88e5b.available)
	x.x = (int32)(x.ref2dc88e5b.x)
	x.y = (int32)(x.ref2dc88e5b.y)
	x.width = (int32)(x.ref2dc88e5b.width)
	x.height = (int32)(x.ref2dc88e5b.height)
	x.primary = (bool)(x.ref2dc88e5b.primary)
	x.number = (int32)(x.ref2dc88e5b.number)
}

// allocKinc_display_modeMemory allocates memory for type C.kinc_display_mode_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocKinc_display_modeMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfKinc_display_modeValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfKinc_display_modeValue = unsafe.Sizeof([1]C.kinc_display_mode_t{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *kinc_display_mode) Ref() *C.kinc_display_mode_t {
	if x == nil {
		return nil
	}
	return x.ref94597b36
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *kinc_display_mode) Free() {
	if x != nil && x.allocs94597b36 != nil {
		x.allocs94597b36.(*cgoAllocMap).Free()
		x.ref94597b36 = nil
	}
}

// Newkinc_display_modeRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func Newkinc_display_modeRef(ref unsafe.Pointer) *kinc_display_mode {
	if ref == nil {
		return nil
	}
	obj := new(kinc_display_mode)
	obj.ref94597b36 = (*C.kinc_display_mode_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *kinc_display_mode) PassRef() (*C.kinc_display_mode_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref94597b36 != nil {
		return x.ref94597b36, nil
	}
	mem94597b36 := allocKinc_display_modeMemory(1)
	ref94597b36 := (*C.kinc_display_mode_t)(mem94597b36)
	allocs94597b36 := new(cgoAllocMap)
	allocs94597b36.Add(mem94597b36)

	var cx_allocs *cgoAllocMap
	ref94597b36.x, cx_allocs = (C.int)(x.x), cgoAllocsUnknown
	allocs94597b36.Borrow(cx_allocs)

	var cy_allocs *cgoAllocMap
	ref94597b36.y, cy_allocs = (C.int)(x.y), cgoAllocsUnknown
	allocs94597b36.Borrow(cy_allocs)

	var cwidth_allocs *cgoAllocMap
	ref94597b36.width, cwidth_allocs = (C.int)(x.width), cgoAllocsUnknown
	allocs94597b36.Borrow(cwidth_allocs)

	var cheight_allocs *cgoAllocMap
	ref94597b36.height, cheight_allocs = (C.int)(x.height), cgoAllocsUnknown
	allocs94597b36.Borrow(cheight_allocs)

	var cpixels_per_inch_allocs *cgoAllocMap
	ref94597b36.pixels_per_inch, cpixels_per_inch_allocs = (C.int)(x.pixels_per_inch), cgoAllocsUnknown
	allocs94597b36.Borrow(cpixels_per_inch_allocs)

	var cfrequency_allocs *cgoAllocMap
	ref94597b36.frequency, cfrequency_allocs = (C.int)(x.frequency), cgoAllocsUnknown
	allocs94597b36.Borrow(cfrequency_allocs)

	var cbits_per_pixel_allocs *cgoAllocMap
	ref94597b36.bits_per_pixel, cbits_per_pixel_allocs = (C.int)(x.bits_per_pixel), cgoAllocsUnknown
	allocs94597b36.Borrow(cbits_per_pixel_allocs)

	x.ref94597b36 = ref94597b36
	x.allocs94597b36 = allocs94597b36
	return ref94597b36, allocs94597b36

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x kinc_display_mode) PassValue() (C.kinc_display_mode_t, *cgoAllocMap) {
	if x.ref94597b36 != nil {
		return *x.ref94597b36, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *kinc_display_mode) Deref() {
	if x.ref94597b36 == nil {
		return
	}
	x.x = (int32)(x.ref94597b36.x)
	x.y = (int32)(x.ref94597b36.y)
	x.width = (int32)(x.ref94597b36.width)
	x.height = (int32)(x.ref94597b36.height)
	x.pixels_per_inch = (int32)(x.ref94597b36.pixels_per_inch)
	x.frequency = (int32)(x.ref94597b36.frequency)
	x.bits_per_pixel = (int32)(x.ref94597b36.bits_per_pixel)
}

// allocKinc_framebuffer_optionsMemory allocates memory for type C.kinc_framebuffer_options_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocKinc_framebuffer_optionsMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfKinc_framebuffer_optionsValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfKinc_framebuffer_optionsValue = unsafe.Sizeof([1]C.kinc_framebuffer_options_t{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *kinc_framebuffer_options) Ref() *C.kinc_framebuffer_options_t {
	if x == nil {
		return nil
	}
	return x.refe132b968
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *kinc_framebuffer_options) Free() {
	if x != nil && x.allocse132b968 != nil {
		x.allocse132b968.(*cgoAllocMap).Free()
		x.refe132b968 = nil
	}
}

// Newkinc_framebuffer_optionsRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func Newkinc_framebuffer_optionsRef(ref unsafe.Pointer) *kinc_framebuffer_options {
	if ref == nil {
		return nil
	}
	obj := new(kinc_framebuffer_options)
	obj.refe132b968 = (*C.kinc_framebuffer_options_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *kinc_framebuffer_options) PassRef() (*C.kinc_framebuffer_options_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refe132b968 != nil {
		return x.refe132b968, nil
	}
	meme132b968 := allocKinc_framebuffer_optionsMemory(1)
	refe132b968 := (*C.kinc_framebuffer_options_t)(meme132b968)
	allocse132b968 := new(cgoAllocMap)
	allocse132b968.Add(meme132b968)

	var cfrequency_allocs *cgoAllocMap
	refe132b968.frequency, cfrequency_allocs = (C.int)(x.frequency), cgoAllocsUnknown
	allocse132b968.Borrow(cfrequency_allocs)

	var cvertical_sync_allocs *cgoAllocMap
	refe132b968.vertical_sync, cvertical_sync_allocs = (C._Bool)(x.vertical_sync), cgoAllocsUnknown
	allocse132b968.Borrow(cvertical_sync_allocs)

	var ccolor_bits_allocs *cgoAllocMap
	refe132b968.color_bits, ccolor_bits_allocs = (C.int)(x.color_bits), cgoAllocsUnknown
	allocse132b968.Borrow(ccolor_bits_allocs)

	var cdepth_bits_allocs *cgoAllocMap
	refe132b968.depth_bits, cdepth_bits_allocs = (C.int)(x.depth_bits), cgoAllocsUnknown
	allocse132b968.Borrow(cdepth_bits_allocs)

	var cstencil_bits_allocs *cgoAllocMap
	refe132b968.stencil_bits, cstencil_bits_allocs = (C.int)(x.stencil_bits), cgoAllocsUnknown
	allocse132b968.Borrow(cstencil_bits_allocs)

	var csamples_per_pixel_allocs *cgoAllocMap
	refe132b968.samples_per_pixel, csamples_per_pixel_allocs = (C.int)(x.samples_per_pixel), cgoAllocsUnknown
	allocse132b968.Borrow(csamples_per_pixel_allocs)

	x.refe132b968 = refe132b968
	x.allocse132b968 = allocse132b968
	return refe132b968, allocse132b968

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x kinc_framebuffer_options) PassValue() (C.kinc_framebuffer_options_t, *cgoAllocMap) {
	if x.refe132b968 != nil {
		return *x.refe132b968, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *kinc_framebuffer_options) Deref() {
	if x.refe132b968 == nil {
		return
	}
	x.frequency = (int32)(x.refe132b968.frequency)
	x.vertical_sync = (bool)(x.refe132b968.vertical_sync)
	x.color_bits = (int32)(x.refe132b968.color_bits)
	x.depth_bits = (int32)(x.refe132b968.depth_bits)
	x.stencil_bits = (int32)(x.refe132b968.stencil_bits)
	x.samples_per_pixel = (int32)(x.refe132b968.samples_per_pixel)
}

// allocKinc_window_optionsMemory allocates memory for type C.kinc_window_options_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocKinc_window_optionsMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfKinc_window_optionsValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfKinc_window_optionsValue = unsafe.Sizeof([1]C.kinc_window_options_t{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *kinc_window_options) Ref() *C.kinc_window_options_t {
	if x == nil {
		return nil
	}
	return x.ref6b7e4003
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *kinc_window_options) Free() {
	if x != nil && x.allocs6b7e4003 != nil {
		x.allocs6b7e4003.(*cgoAllocMap).Free()
		x.ref6b7e4003 = nil
	}
}

// Newkinc_window_optionsRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func Newkinc_window_optionsRef(ref unsafe.Pointer) *kinc_window_options {
	if ref == nil {
		return nil
	}
	obj := new(kinc_window_options)
	obj.ref6b7e4003 = (*C.kinc_window_options_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *kinc_window_options) PassRef() (*C.kinc_window_options_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref6b7e4003 != nil {
		return x.ref6b7e4003, nil
	}
	mem6b7e4003 := allocKinc_window_optionsMemory(1)
	ref6b7e4003 := (*C.kinc_window_options_t)(mem6b7e4003)
	allocs6b7e4003 := new(cgoAllocMap)
	allocs6b7e4003.Add(mem6b7e4003)

	var ctitle_allocs *cgoAllocMap
	ref6b7e4003.title, ctitle_allocs = unpackPCharString(x.title)
	allocs6b7e4003.Borrow(ctitle_allocs)

	var cx_allocs *cgoAllocMap
	ref6b7e4003.x, cx_allocs = (C.int)(x.x), cgoAllocsUnknown
	allocs6b7e4003.Borrow(cx_allocs)

	var cy_allocs *cgoAllocMap
	ref6b7e4003.y, cy_allocs = (C.int)(x.y), cgoAllocsUnknown
	allocs6b7e4003.Borrow(cy_allocs)

	var cwidth_allocs *cgoAllocMap
	ref6b7e4003.width, cwidth_allocs = (C.int)(x.width), cgoAllocsUnknown
	allocs6b7e4003.Borrow(cwidth_allocs)

	var cheight_allocs *cgoAllocMap
	ref6b7e4003.height, cheight_allocs = (C.int)(x.height), cgoAllocsUnknown
	allocs6b7e4003.Borrow(cheight_allocs)

	var cdisplay_index_allocs *cgoAllocMap
	ref6b7e4003.display_index, cdisplay_index_allocs = (C.int)(x.display_index), cgoAllocsUnknown
	allocs6b7e4003.Borrow(cdisplay_index_allocs)

	var cvisible_allocs *cgoAllocMap
	ref6b7e4003.visible, cvisible_allocs = (C._Bool)(x.visible), cgoAllocsUnknown
	allocs6b7e4003.Borrow(cvisible_allocs)

	var cwindow_features_allocs *cgoAllocMap
	ref6b7e4003.window_features, cwindow_features_allocs = (C.int)(x.window_features), cgoAllocsUnknown
	allocs6b7e4003.Borrow(cwindow_features_allocs)

	var cmode_allocs *cgoAllocMap
	ref6b7e4003.mode, cmode_allocs = (C.kinc_window_mode_t)(x.mode), cgoAllocsUnknown
	allocs6b7e4003.Borrow(cmode_allocs)

	x.ref6b7e4003 = ref6b7e4003
	x.allocs6b7e4003 = allocs6b7e4003
	return ref6b7e4003, allocs6b7e4003

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x kinc_window_options) PassValue() (C.kinc_window_options_t, *cgoAllocMap) {
	if x.ref6b7e4003 != nil {
		return *x.ref6b7e4003, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *kinc_window_options) Deref() {
	if x.ref6b7e4003 == nil {
		return
	}
	x.title = packPCharString(x.ref6b7e4003.title)
	x.x = (int32)(x.ref6b7e4003.x)
	x.y = (int32)(x.ref6b7e4003.y)
	x.width = (int32)(x.ref6b7e4003.width)
	x.height = (int32)(x.ref6b7e4003.height)
	x.display_index = (int32)(x.ref6b7e4003.display_index)
	x.visible = (bool)(x.ref6b7e4003.visible)
	x.window_features = (int32)(x.ref6b7e4003.window_features)
	x.mode = (kinc_window_mode)(x.ref6b7e4003.mode)
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *kinc_image) Ref() *C.kinc_image_t {
	if x == nil {
		return nil
	}
	return x.refa3fab79c
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *kinc_image) Free() {
	if x != nil && x.allocsa3fab79c != nil {
		x.allocsa3fab79c.(*cgoAllocMap).Free()
		x.refa3fab79c = nil
	}
}

// Newkinc_imageRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func Newkinc_imageRef(ref unsafe.Pointer) *kinc_image {
	if ref == nil {
		return nil
	}
	obj := new(kinc_image)
	obj.refa3fab79c = (*C.kinc_image_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *kinc_image) PassRef() (*C.kinc_image_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refa3fab79c != nil {
		return x.refa3fab79c, nil
	}
	mema3fab79c := allocKinc_imageMemory(1)
	refa3fab79c := (*C.kinc_image_t)(mema3fab79c)
	allocsa3fab79c := new(cgoAllocMap)
	allocsa3fab79c.Add(mema3fab79c)

	var cwidth_allocs *cgoAllocMap
	refa3fab79c.width, cwidth_allocs = (C.int)(x.width), cgoAllocsUnknown
	allocsa3fab79c.Borrow(cwidth_allocs)

	var cheight_allocs *cgoAllocMap
	refa3fab79c.height, cheight_allocs = (C.int)(x.height), cgoAllocsUnknown
	allocsa3fab79c.Borrow(cheight_allocs)

	var cdepth_allocs *cgoAllocMap
	refa3fab79c.depth, cdepth_allocs = (C.int)(x.depth), cgoAllocsUnknown
	allocsa3fab79c.Borrow(cdepth_allocs)

	var cformat_allocs *cgoAllocMap
	refa3fab79c.format, cformat_allocs = (C.kinc_image_format_t)(x.format), cgoAllocsUnknown
	allocsa3fab79c.Borrow(cformat_allocs)

	var cinternal_format_allocs *cgoAllocMap
	refa3fab79c.internal_format, cinternal_format_allocs = (C.uint)(x.internal_format), cgoAllocsUnknown
	allocsa3fab79c.Borrow(cinternal_format_allocs)

	var ccompression_allocs *cgoAllocMap
	refa3fab79c.compression, ccompression_allocs = (C.kinc_image_compression_t)(x.compression), cgoAllocsUnknown
	allocsa3fab79c.Borrow(ccompression_allocs)

	var cdata_allocs *cgoAllocMap
	refa3fab79c.data, cdata_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.data)), cgoAllocsUnknown
	allocsa3fab79c.Borrow(cdata_allocs)

	var cdata_size_allocs *cgoAllocMap
	refa3fab79c.data_size, cdata_size_allocs = (C.int)(x.data_size), cgoAllocsUnknown
	allocsa3fab79c.Borrow(cdata_size_allocs)

	x.refa3fab79c = refa3fab79c
	x.allocsa3fab79c = allocsa3fab79c
	return refa3fab79c, allocsa3fab79c

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x kinc_image) PassValue() (C.kinc_image_t, *cgoAllocMap) {
	if x.refa3fab79c != nil {
		return *x.refa3fab79c, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *kinc_image) Deref() {
	if x.refa3fab79c == nil {
		return
	}
	x.width = (int32)(x.refa3fab79c.width)
	x.height = (int32)(x.refa3fab79c.height)
	x.depth = (int32)(x.refa3fab79c.depth)
	x.format = (kinc_image_format)(x.refa3fab79c.format)
	x.internal_format = (uint32)(x.refa3fab79c.internal_format)
	x.compression = (kinc_image_compression)(x.refa3fab79c.compression)
	x.data = (unsafe.Pointer)(unsafe.Pointer(x.refa3fab79c.data))
	x.data_size = (int32)(x.refa3fab79c.data_size)
}

// allocKinc_matrix3x3Memory allocates memory for type C.kinc_matrix3x3_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocKinc_matrix3x3Memory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfKinc_matrix3x3Value))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfKinc_matrix3x3Value = unsafe.Sizeof([1]C.kinc_matrix3x3_t{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *kinc_matrix3x3) Ref() *C.kinc_matrix3x3_t {
	if x == nil {
		return nil
	}
	return x.ref1a91c52a
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *kinc_matrix3x3) Free() {
	if x != nil && x.allocs1a91c52a != nil {
		x.allocs1a91c52a.(*cgoAllocMap).Free()
		x.ref1a91c52a = nil
	}
}

// Newkinc_matrix3x3Ref creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func Newkinc_matrix3x3Ref(ref unsafe.Pointer) *kinc_matrix3x3 {
	if ref == nil {
		return nil
	}
	obj := new(kinc_matrix3x3)
	obj.ref1a91c52a = (*C.kinc_matrix3x3_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *kinc_matrix3x3) PassRef() (*C.kinc_matrix3x3_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref1a91c52a != nil {
		return x.ref1a91c52a, nil
	}
	mem1a91c52a := allocKinc_matrix3x3Memory(1)
	ref1a91c52a := (*C.kinc_matrix3x3_t)(mem1a91c52a)
	allocs1a91c52a := new(cgoAllocMap)
	allocs1a91c52a.Add(mem1a91c52a)

	var cm_allocs *cgoAllocMap
	ref1a91c52a.m, cm_allocs = *(*[9]C.float)(unsafe.Pointer(&x.m)), cgoAllocsUnknown
	allocs1a91c52a.Borrow(cm_allocs)

	x.ref1a91c52a = ref1a91c52a
	x.allocs1a91c52a = allocs1a91c52a
	return ref1a91c52a, allocs1a91c52a

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x kinc_matrix3x3) PassValue() (C.kinc_matrix3x3_t, *cgoAllocMap) {
	if x.ref1a91c52a != nil {
		return *x.ref1a91c52a, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *kinc_matrix3x3) Deref() {
	if x.ref1a91c52a == nil {
		return
	}
	x.m = *(*[9]float32)(unsafe.Pointer(&x.ref1a91c52a.m))
}

// allocKinc_matrix4x4Memory allocates memory for type C.kinc_matrix4x4_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocKinc_matrix4x4Memory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfKinc_matrix4x4Value))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfKinc_matrix4x4Value = unsafe.Sizeof([1]C.kinc_matrix4x4_t{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *kinc_matrix4x4) Ref() *C.kinc_matrix4x4_t {
	if x == nil {
		return nil
	}
	return x.refadfe0fbf
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *kinc_matrix4x4) Free() {
	if x != nil && x.allocsadfe0fbf != nil {
		x.allocsadfe0fbf.(*cgoAllocMap).Free()
		x.refadfe0fbf = nil
	}
}

// Newkinc_matrix4x4Ref creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func Newkinc_matrix4x4Ref(ref unsafe.Pointer) *kinc_matrix4x4 {
	if ref == nil {
		return nil
	}
	obj := new(kinc_matrix4x4)
	obj.refadfe0fbf = (*C.kinc_matrix4x4_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *kinc_matrix4x4) PassRef() (*C.kinc_matrix4x4_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refadfe0fbf != nil {
		return x.refadfe0fbf, nil
	}
	memadfe0fbf := allocKinc_matrix4x4Memory(1)
	refadfe0fbf := (*C.kinc_matrix4x4_t)(memadfe0fbf)
	allocsadfe0fbf := new(cgoAllocMap)
	allocsadfe0fbf.Add(memadfe0fbf)

	var cm_allocs *cgoAllocMap
	refadfe0fbf.m, cm_allocs = *(*[16]C.float)(unsafe.Pointer(&x.m)), cgoAllocsUnknown
	allocsadfe0fbf.Borrow(cm_allocs)

	x.refadfe0fbf = refadfe0fbf
	x.allocsadfe0fbf = allocsadfe0fbf
	return refadfe0fbf, allocsadfe0fbf

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x kinc_matrix4x4) PassValue() (C.kinc_matrix4x4_t, *cgoAllocMap) {
	if x.refadfe0fbf != nil {
		return *x.refadfe0fbf, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *kinc_matrix4x4) Deref() {
	if x.refadfe0fbf == nil {
		return
	}
	x.m = *(*[16]float32)(unsafe.Pointer(&x.refadfe0fbf.m))
}

// allocKinc_g4_constant_locationMemory allocates memory for type C.kinc_g4_constant_location_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocKinc_g4_constant_locationMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfKinc_g4_constant_locationValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfKinc_g4_constant_locationValue = unsafe.Sizeof([1]C.kinc_g4_constant_location_t{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *kinc_g4_constant_location) Ref() *C.kinc_g4_constant_location_t {
	if x == nil {
		return nil
	}
	return x.refbe80a563
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *kinc_g4_constant_location) Free() {
	if x != nil && x.allocsbe80a563 != nil {
		x.allocsbe80a563.(*cgoAllocMap).Free()
		x.refbe80a563 = nil
	}
}

// Newkinc_g4_constant_locationRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func Newkinc_g4_constant_locationRef(ref unsafe.Pointer) *kinc_g4_constant_location {
	if ref == nil {
		return nil
	}
	obj := new(kinc_g4_constant_location)
	obj.refbe80a563 = (*C.kinc_g4_constant_location_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *kinc_g4_constant_location) PassRef() (*C.kinc_g4_constant_location_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refbe80a563 != nil {
		return x.refbe80a563, nil
	}
	membe80a563 := allocKinc_g4_constant_locationMemory(1)
	refbe80a563 := (*C.kinc_g4_constant_location_t)(membe80a563)
	allocsbe80a563 := new(cgoAllocMap)
	allocsbe80a563.Add(membe80a563)

	var cimpl_allocs *cgoAllocMap
	refbe80a563.impl, cimpl_allocs = x.impl.PassValue()
	allocsbe80a563.Borrow(cimpl_allocs)

	x.refbe80a563 = refbe80a563
	x.allocsbe80a563 = allocsbe80a563
	return refbe80a563, allocsbe80a563

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x kinc_g4_constant_location) PassValue() (C.kinc_g4_constant_location_t, *cgoAllocMap) {
	if x.refbe80a563 != nil {
		return *x.refbe80a563, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *kinc_g4_constant_location) Deref() {
	if x.refbe80a563 == nil {
		return
	}
	x.impl = *Newkinc_g4_constant_location_implRef(unsafe.Pointer(&x.refbe80a563.impl))
}

// allocKinc_g4_pipeline_implMemory allocates memory for type C.kinc_g4_pipeline_impl_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocKinc_g4_pipeline_implMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfKinc_g4_pipeline_implValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfKinc_g4_pipeline_implValue = unsafe.Sizeof([1]C.kinc_g4_pipeline_impl_t{})

// allocPCharMemory allocates memory for type *C.char in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPCharMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPCharValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPCharValue = unsafe.Sizeof([1]*C.char{})

// unpackSSByte transforms a sliced Go data structure into plain C format.
func unpackSSByte(x [][]byte) (unpacked **C.char, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocPCharMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]*C.char)(unsafe.Pointer(h0))
	for i0 := range x {
		h := (*sliceHeader)(unsafe.Pointer(&x[i0]))
		v0[i0] = (*C.char)(h.Data)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (**C.char)(h.Data)
	return
}

// packSSByte reads sliced Go data structure out from plain C format.
func packSSByte(v [][]byte, ptr0 **C.char) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPtr]*C.char)(unsafe.Pointer(ptr0)))[i0]
		hxff2234b := (*sliceHeader)(unsafe.Pointer(&v[i0]))
		hxff2234b.Data = unsafe.Pointer(ptr1)
		hxff2234b.Cap = 0x7fffffff
		// hxff2234b.Len = ?
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *kinc_g4_pipeline_impl) Ref() *C.kinc_g4_pipeline_impl_t {
	if x == nil {
		return nil
	}
	return x.ref4662c110
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *kinc_g4_pipeline_impl) Free() {
	if x != nil && x.allocs4662c110 != nil {
		x.allocs4662c110.(*cgoAllocMap).Free()
		x.ref4662c110 = nil
	}
}

// Newkinc_g4_pipeline_implRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func Newkinc_g4_pipeline_implRef(ref unsafe.Pointer) *kinc_g4_pipeline_impl {
	if ref == nil {
		return nil
	}
	obj := new(kinc_g4_pipeline_impl)
	obj.ref4662c110 = (*C.kinc_g4_pipeline_impl_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *kinc_g4_pipeline_impl) PassRef() (*C.kinc_g4_pipeline_impl_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref4662c110 != nil {
		return x.ref4662c110, nil
	}
	mem4662c110 := allocKinc_g4_pipeline_implMemory(1)
	ref4662c110 := (*C.kinc_g4_pipeline_impl_t)(mem4662c110)
	allocs4662c110 := new(cgoAllocMap)
	allocs4662c110.Add(mem4662c110)

	var cprogramId_allocs *cgoAllocMap
	ref4662c110.programId, cprogramId_allocs = (C.uint)(x.programid), cgoAllocsUnknown
	allocs4662c110.Borrow(cprogramId_allocs)

	var ctextures_allocs *cgoAllocMap
	ref4662c110.textures, ctextures_allocs = unpackSSByte(x.textures)
	allocs4662c110.Borrow(ctextures_allocs)

	var ctextureValues_allocs *cgoAllocMap
	ref4662c110.textureValues, ctextureValues_allocs = copyPIntBytes((*sliceHeader)(unsafe.Pointer(&x.texturevalues)))
	allocs4662c110.Borrow(ctextureValues_allocs)

	var ctextureCount_allocs *cgoAllocMap
	ref4662c110.textureCount, ctextureCount_allocs = (C.int)(x.texturecount), cgoAllocsUnknown
	allocs4662c110.Borrow(ctextureCount_allocs)

	x.ref4662c110 = ref4662c110
	x.allocs4662c110 = allocs4662c110
	return ref4662c110, allocs4662c110

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x kinc_g4_pipeline_impl) PassValue() (C.kinc_g4_pipeline_impl_t, *cgoAllocMap) {
	if x.ref4662c110 != nil {
		return *x.ref4662c110, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *kinc_g4_pipeline_impl) Deref() {
	if x.ref4662c110 == nil {
		return
	}
	x.programid = (uint32)(x.ref4662c110.programId)
	packSSByte(x.textures, x.ref4662c110.textures)
	hxff73280 := (*sliceHeader)(unsafe.Pointer(&x.texturevalues))
	hxff73280.Data = unsafe.Pointer(x.ref4662c110.textureValues)
	hxff73280.Cap = 0x7fffffff
	// hxff73280.Len = ?

	x.texturecount = (int32)(x.ref4662c110.textureCount)
}

// allocKinc_g4_shader_implMemory allocates memory for type C.kinc_g4_shader_impl_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocKinc_g4_shader_implMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfKinc_g4_shader_implValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfKinc_g4_shader_implValue = unsafe.Sizeof([1]C.kinc_g4_shader_impl_t{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *kinc_g4_shader_impl) Ref() *C.kinc_g4_shader_impl_t {
	if x == nil {
		return nil
	}
	return x.ref6566042f
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *kinc_g4_shader_impl) Free() {
	if x != nil && x.allocs6566042f != nil {
		x.allocs6566042f.(*cgoAllocMap).Free()
		x.ref6566042f = nil
	}
}

// Newkinc_g4_shader_implRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func Newkinc_g4_shader_implRef(ref unsafe.Pointer) *kinc_g4_shader_impl {
	if ref == nil {
		return nil
	}
	obj := new(kinc_g4_shader_impl)
	obj.ref6566042f = (*C.kinc_g4_shader_impl_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *kinc_g4_shader_impl) PassRef() (*C.kinc_g4_shader_impl_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref6566042f != nil {
		return x.ref6566042f, nil
	}
	mem6566042f := allocKinc_g4_shader_implMemory(1)
	ref6566042f := (*C.kinc_g4_shader_impl_t)(mem6566042f)
	allocs6566042f := new(cgoAllocMap)
	allocs6566042f.Add(mem6566042f)

	var c_glid_allocs *cgoAllocMap
	ref6566042f._glid, c_glid_allocs = (C.uint)(x._glid), cgoAllocsUnknown
	allocs6566042f.Borrow(c_glid_allocs)

	var csource_allocs *cgoAllocMap
	ref6566042f.source, csource_allocs = unpackPCharString(x.source)
	allocs6566042f.Borrow(csource_allocs)

	var clength_allocs *cgoAllocMap
	ref6566042f.length, clength_allocs = (C.size_t)(x.length), cgoAllocsUnknown
	allocs6566042f.Borrow(clength_allocs)

	var cfromSource_allocs *cgoAllocMap
	ref6566042f.fromSource, cfromSource_allocs = (C._Bool)(x.fromsource), cgoAllocsUnknown
	allocs6566042f.Borrow(cfromSource_allocs)

	x.ref6566042f = ref6566042f
	x.allocs6566042f = allocs6566042f
	return ref6566042f, allocs6566042f

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x kinc_g4_shader_impl) PassValue() (C.kinc_g4_shader_impl_t, *cgoAllocMap) {
	if x.ref6566042f != nil {
		return *x.ref6566042f, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *kinc_g4_shader_impl) Deref() {
	if x.ref6566042f == nil {
		return
	}
	x._glid = (uint32)(x.ref6566042f._glid)
	x.source = packPCharString(x.ref6566042f.source)
	x.length = (uint)(x.ref6566042f.length)
	x.fromsource = (bool)(x.ref6566042f.fromSource)
}

// allocKinc_g4_constant_location_implMemory allocates memory for type C.kinc_g4_constant_location_impl_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocKinc_g4_constant_location_implMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfKinc_g4_constant_location_implValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfKinc_g4_constant_location_implValue = unsafe.Sizeof([1]C.kinc_g4_constant_location_impl_t{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *kinc_g4_constant_location_impl) Ref() *C.kinc_g4_constant_location_impl_t {
	if x == nil {
		return nil
	}
	return x.ref67254fde
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *kinc_g4_constant_location_impl) Free() {
	if x != nil && x.allocs67254fde != nil {
		x.allocs67254fde.(*cgoAllocMap).Free()
		x.ref67254fde = nil
	}
}

// Newkinc_g4_constant_location_implRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func Newkinc_g4_constant_location_implRef(ref unsafe.Pointer) *kinc_g4_constant_location_impl {
	if ref == nil {
		return nil
	}
	obj := new(kinc_g4_constant_location_impl)
	obj.ref67254fde = (*C.kinc_g4_constant_location_impl_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *kinc_g4_constant_location_impl) PassRef() (*C.kinc_g4_constant_location_impl_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref67254fde != nil {
		return x.ref67254fde, nil
	}
	mem67254fde := allocKinc_g4_constant_location_implMemory(1)
	ref67254fde := (*C.kinc_g4_constant_location_impl_t)(mem67254fde)
	allocs67254fde := new(cgoAllocMap)
	allocs67254fde.Add(mem67254fde)

	var clocation_allocs *cgoAllocMap
	ref67254fde.location, clocation_allocs = (C.int)(x.location), cgoAllocsUnknown
	allocs67254fde.Borrow(clocation_allocs)

	var c_type_allocs *cgoAllocMap
	ref67254fde._type, c_type_allocs = (C.uint)(x._type), cgoAllocsUnknown
	allocs67254fde.Borrow(c_type_allocs)

	x.ref67254fde = ref67254fde
	x.allocs67254fde = allocs67254fde
	return ref67254fde, allocs67254fde

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x kinc_g4_constant_location_impl) PassValue() (C.kinc_g4_constant_location_impl_t, *cgoAllocMap) {
	if x.ref67254fde != nil {
		return *x.ref67254fde, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *kinc_g4_constant_location_impl) Deref() {
	if x.ref67254fde == nil {
		return
	}
	x.location = (int32)(x.ref67254fde.location)
	x._type = (uint32)(x.ref67254fde._type)
}

// allocKinc_g4_texture_unit_implMemory allocates memory for type C.kinc_g4_texture_unit_impl_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocKinc_g4_texture_unit_implMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfKinc_g4_texture_unit_implValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfKinc_g4_texture_unit_implValue = unsafe.Sizeof([1]C.kinc_g4_texture_unit_impl_t{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *kinc_g4_texture_unit_impl) Ref() *C.kinc_g4_texture_unit_impl_t {
	if x == nil {
		return nil
	}
	return x.ref496fb85c
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *kinc_g4_texture_unit_impl) Free() {
	if x != nil && x.allocs496fb85c != nil {
		x.allocs496fb85c.(*cgoAllocMap).Free()
		x.ref496fb85c = nil
	}
}

// Newkinc_g4_texture_unit_implRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func Newkinc_g4_texture_unit_implRef(ref unsafe.Pointer) *kinc_g4_texture_unit_impl {
	if ref == nil {
		return nil
	}
	obj := new(kinc_g4_texture_unit_impl)
	obj.ref496fb85c = (*C.kinc_g4_texture_unit_impl_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *kinc_g4_texture_unit_impl) PassRef() (*C.kinc_g4_texture_unit_impl_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref496fb85c != nil {
		return x.ref496fb85c, nil
	}
	mem496fb85c := allocKinc_g4_texture_unit_implMemory(1)
	ref496fb85c := (*C.kinc_g4_texture_unit_impl_t)(mem496fb85c)
	allocs496fb85c := new(cgoAllocMap)
	allocs496fb85c.Add(mem496fb85c)

	var cunit_allocs *cgoAllocMap
	ref496fb85c.unit, cunit_allocs = (C.int)(x.unit), cgoAllocsUnknown
	allocs496fb85c.Borrow(cunit_allocs)

	x.ref496fb85c = ref496fb85c
	x.allocs496fb85c = allocs496fb85c
	return ref496fb85c, allocs496fb85c

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x kinc_g4_texture_unit_impl) PassValue() (C.kinc_g4_texture_unit_impl_t, *cgoAllocMap) {
	if x.ref496fb85c != nil {
		return *x.ref496fb85c, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *kinc_g4_texture_unit_impl) Deref() {
	if x.ref496fb85c == nil {
		return
	}
	x.unit = (int32)(x.ref496fb85c.unit)
}

// allocKinc_g4_texture_unitMemory allocates memory for type C.kinc_g4_texture_unit_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocKinc_g4_texture_unitMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfKinc_g4_texture_unitValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfKinc_g4_texture_unitValue = unsafe.Sizeof([1]C.kinc_g4_texture_unit_t{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *kinc_g4_texture_unit) Ref() *C.kinc_g4_texture_unit_t {
	if x == nil {
		return nil
	}
	return x.ref8e8b8b97
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *kinc_g4_texture_unit) Free() {
	if x != nil && x.allocs8e8b8b97 != nil {
		x.allocs8e8b8b97.(*cgoAllocMap).Free()
		x.ref8e8b8b97 = nil
	}
}

// Newkinc_g4_texture_unitRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func Newkinc_g4_texture_unitRef(ref unsafe.Pointer) *kinc_g4_texture_unit {
	if ref == nil {
		return nil
	}
	obj := new(kinc_g4_texture_unit)
	obj.ref8e8b8b97 = (*C.kinc_g4_texture_unit_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *kinc_g4_texture_unit) PassRef() (*C.kinc_g4_texture_unit_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref8e8b8b97 != nil {
		return x.ref8e8b8b97, nil
	}
	mem8e8b8b97 := allocKinc_g4_texture_unitMemory(1)
	ref8e8b8b97 := (*C.kinc_g4_texture_unit_t)(mem8e8b8b97)
	allocs8e8b8b97 := new(cgoAllocMap)
	allocs8e8b8b97.Add(mem8e8b8b97)

	var cimpl_allocs *cgoAllocMap
	ref8e8b8b97.impl, cimpl_allocs = x.impl.PassValue()
	allocs8e8b8b97.Borrow(cimpl_allocs)

	x.ref8e8b8b97 = ref8e8b8b97
	x.allocs8e8b8b97 = allocs8e8b8b97
	return ref8e8b8b97, allocs8e8b8b97

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x kinc_g4_texture_unit) PassValue() (C.kinc_g4_texture_unit_t, *cgoAllocMap) {
	if x.ref8e8b8b97 != nil {
		return *x.ref8e8b8b97, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *kinc_g4_texture_unit) Deref() {
	if x.ref8e8b8b97 == nil {
		return
	}
	x.impl = *Newkinc_g4_texture_unit_implRef(unsafe.Pointer(&x.ref8e8b8b97.impl))
}

// allocKinc_g4_texture_implMemory allocates memory for type C.kinc_g4_texture_impl_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocKinc_g4_texture_implMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfKinc_g4_texture_implValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfKinc_g4_texture_implValue = unsafe.Sizeof([1]C.kinc_g4_texture_impl_t{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *kinc_g4_texture_impl) Ref() *C.kinc_g4_texture_impl_t {
	if x == nil {
		return nil
	}
	return x.ref821bd97a
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *kinc_g4_texture_impl) Free() {
	if x != nil && x.allocs821bd97a != nil {
		x.allocs821bd97a.(*cgoAllocMap).Free()
		x.ref821bd97a = nil
	}
}

// Newkinc_g4_texture_implRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func Newkinc_g4_texture_implRef(ref unsafe.Pointer) *kinc_g4_texture_impl {
	if ref == nil {
		return nil
	}
	obj := new(kinc_g4_texture_impl)
	obj.ref821bd97a = (*C.kinc_g4_texture_impl_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *kinc_g4_texture_impl) PassRef() (*C.kinc_g4_texture_impl_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref821bd97a != nil {
		return x.ref821bd97a, nil
	}
	mem821bd97a := allocKinc_g4_texture_implMemory(1)
	ref821bd97a := (*C.kinc_g4_texture_impl_t)(mem821bd97a)
	allocs821bd97a := new(cgoAllocMap)
	allocs821bd97a.Add(mem821bd97a)

	var ctexture_allocs *cgoAllocMap
	ref821bd97a.texture, ctexture_allocs = (C.uint)(x.texture), cgoAllocsUnknown
	allocs821bd97a.Borrow(ctexture_allocs)

	var cpixfmt_allocs *cgoAllocMap
	ref821bd97a.pixfmt, cpixfmt_allocs = (C.uint8_t)(x.pixfmt), cgoAllocsUnknown
	allocs821bd97a.Borrow(cpixfmt_allocs)

	x.ref821bd97a = ref821bd97a
	x.allocs821bd97a = allocs821bd97a
	return ref821bd97a, allocs821bd97a

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x kinc_g4_texture_impl) PassValue() (C.kinc_g4_texture_impl_t, *cgoAllocMap) {
	if x.ref821bd97a != nil {
		return *x.ref821bd97a, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *kinc_g4_texture_impl) Deref() {
	if x.ref821bd97a == nil {
		return
	}
	x.texture = (uint32)(x.ref821bd97a.texture)
	x.pixfmt = (byte)(x.ref821bd97a.pixfmt)
}

// allocKinc_g4_index_bufferMemory allocates memory for type C.kinc_g4_index_buffer_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocKinc_g4_index_bufferMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfKinc_g4_index_bufferValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfKinc_g4_index_bufferValue = unsafe.Sizeof([1]C.kinc_g4_index_buffer_t{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *kinc_g4_index_buffer) Ref() *C.kinc_g4_index_buffer_t {
	if x == nil {
		return nil
	}
	return x.refc241ba04
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *kinc_g4_index_buffer) Free() {
	if x != nil && x.allocsc241ba04 != nil {
		x.allocsc241ba04.(*cgoAllocMap).Free()
		x.refc241ba04 = nil
	}
}

// Newkinc_g4_index_bufferRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func Newkinc_g4_index_bufferRef(ref unsafe.Pointer) *kinc_g4_index_buffer {
	if ref == nil {
		return nil
	}
	obj := new(kinc_g4_index_buffer)
	obj.refc241ba04 = (*C.kinc_g4_index_buffer_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *kinc_g4_index_buffer) PassRef() (*C.kinc_g4_index_buffer_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refc241ba04 != nil {
		return x.refc241ba04, nil
	}
	memc241ba04 := allocKinc_g4_index_bufferMemory(1)
	refc241ba04 := (*C.kinc_g4_index_buffer_t)(memc241ba04)
	allocsc241ba04 := new(cgoAllocMap)
	allocsc241ba04.Add(memc241ba04)

	var cimpl_allocs *cgoAllocMap
	refc241ba04.impl, cimpl_allocs = x.impl.PassValue()
	allocsc241ba04.Borrow(cimpl_allocs)

	x.refc241ba04 = refc241ba04
	x.allocsc241ba04 = allocsc241ba04
	return refc241ba04, allocsc241ba04

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x kinc_g4_index_buffer) PassValue() (C.kinc_g4_index_buffer_t, *cgoAllocMap) {
	if x.refc241ba04 != nil {
		return *x.refc241ba04, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *kinc_g4_index_buffer) Deref() {
	if x.refc241ba04 == nil {
		return
	}
	x.impl = *Newkinc_g4_index_buffer_implRef(unsafe.Pointer(&x.refc241ba04.impl))
}

// allocKinc_g4_index_buffer_implMemory allocates memory for type C.kinc_g4_index_buffer_impl_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocKinc_g4_index_buffer_implMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfKinc_g4_index_buffer_implValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfKinc_g4_index_buffer_implValue = unsafe.Sizeof([1]C.kinc_g4_index_buffer_impl_t{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *kinc_g4_index_buffer_impl) Ref() *C.kinc_g4_index_buffer_impl_t {
	if x == nil {
		return nil
	}
	return x.ref57aa69c7
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *kinc_g4_index_buffer_impl) Free() {
	if x != nil && x.allocs57aa69c7 != nil {
		x.allocs57aa69c7.(*cgoAllocMap).Free()
		x.ref57aa69c7 = nil
	}
}

// Newkinc_g4_index_buffer_implRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func Newkinc_g4_index_buffer_implRef(ref unsafe.Pointer) *kinc_g4_index_buffer_impl {
	if ref == nil {
		return nil
	}
	obj := new(kinc_g4_index_buffer_impl)
	obj.ref57aa69c7 = (*C.kinc_g4_index_buffer_impl_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *kinc_g4_index_buffer_impl) PassRef() (*C.kinc_g4_index_buffer_impl_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref57aa69c7 != nil {
		return x.ref57aa69c7, nil
	}
	mem57aa69c7 := allocKinc_g4_index_buffer_implMemory(1)
	ref57aa69c7 := (*C.kinc_g4_index_buffer_impl_t)(mem57aa69c7)
	allocs57aa69c7 := new(cgoAllocMap)
	allocs57aa69c7.Add(mem57aa69c7)

	var cdata_allocs *cgoAllocMap
	ref57aa69c7.data, cdata_allocs = copyPIntBytes((*sliceHeader)(unsafe.Pointer(&x.data)))
	allocs57aa69c7.Borrow(cdata_allocs)

	var cmyCount_allocs *cgoAllocMap
	ref57aa69c7.myCount, cmyCount_allocs = (C.int)(x.mycount), cgoAllocsUnknown
	allocs57aa69c7.Borrow(cmyCount_allocs)

	var cbufferId_allocs *cgoAllocMap
	ref57aa69c7.bufferId, cbufferId_allocs = (C.uint)(x.bufferid), cgoAllocsUnknown
	allocs57aa69c7.Borrow(cbufferId_allocs)

	x.ref57aa69c7 = ref57aa69c7
	x.allocs57aa69c7 = allocs57aa69c7
	return ref57aa69c7, allocs57aa69c7

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x kinc_g4_index_buffer_impl) PassValue() (C.kinc_g4_index_buffer_impl_t, *cgoAllocMap) {
	if x.ref57aa69c7 != nil {
		return *x.ref57aa69c7, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *kinc_g4_index_buffer_impl) Deref() {
	if x.ref57aa69c7 == nil {
		return
	}
	hxfa9955c := (*sliceHeader)(unsafe.Pointer(&x.data))
	hxfa9955c.Data = unsafe.Pointer(x.ref57aa69c7.data)
	hxfa9955c.Cap = 0x7fffffff
	// hxfa9955c.Len = ?

	x.mycount = (int32)(x.ref57aa69c7.myCount)
	x.bufferid = (uint32)(x.ref57aa69c7.bufferId)
}

// allocKinc_g4_pipelineMemory allocates memory for type C.kinc_g4_pipeline_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocKinc_g4_pipelineMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfKinc_g4_pipelineValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfKinc_g4_pipelineValue = unsafe.Sizeof([1]C.kinc_g4_pipeline_t{})

// allocA16PStruct_kinc_g4_vertex_structureMemory allocates memory for type [16]*C.struct_kinc_g4_vertex_structure in C.
// The caller is responsible for freeing the this memory via C.free.
func allocA16PStruct_kinc_g4_vertex_structureMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfA16PStruct_kinc_g4_vertex_structureValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfA16PStruct_kinc_g4_vertex_structureValue = unsafe.Sizeof([1][16]*C.struct_kinc_g4_vertex_structure{})

// unpackA16PKinc_g4_vertex_structure transforms a sliced Go data structure into plain C format.
func unpackA16PKinc_g4_vertex_structure(x [16]*kinc_g4_vertex_structure) (unpacked [16]*C.struct_kinc_g4_vertex_structure, allocs *cgoAllocMap) {
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := allocA16PStruct_kinc_g4_vertex_structureMemory(1)
	allocs.Add(mem0)
	v0 := (*[16]*C.struct_kinc_g4_vertex_structure)(mem0)
	for i0 := range x {
		v0[i0], _ = x[i0].PassRef()
	}
	unpacked = *(*[16]*C.struct_kinc_g4_vertex_structure)(mem0)
	return
}

// allocStruct_kinc_g4_shaderMemory allocates memory for type C.struct_kinc_g4_shader in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStruct_kinc_g4_shaderMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStruct_kinc_g4_shaderValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfStruct_kinc_g4_shaderValue = unsafe.Sizeof([1]C.struct_kinc_g4_shader{})

// unpackSKinc_g4_shader transforms a sliced Go data structure into plain C format.
func unpackSKinc_g4_shader(x []kinc_g4_shader) (unpacked *C.struct_kinc_g4_shader, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocStruct_kinc_g4_shaderMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.struct_kinc_g4_shader)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.struct_kinc_g4_shader)(h.Data)
	return
}

// packA16PKinc_g4_vertex_structure reads sliced Go data structure out from plain C format.
func packA16PKinc_g4_vertex_structure(v *[16]*kinc_g4_vertex_structure, ptr0 *[16]*C.struct_kinc_g4_vertex_structure) {
	for i0 := range v {
		ptr1 := ptr0[i0]
		v[i0] = Newkinc_g4_vertex_structureRef(unsafe.Pointer(ptr1))
	}
}

// packSKinc_g4_shader reads sliced Go data structure out from plain C format.
func packSKinc_g4_shader(v []kinc_g4_shader, ptr0 *C.struct_kinc_g4_shader) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfStruct_kinc_g4_shaderValue]C.struct_kinc_g4_shader)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *Newkinc_g4_shaderRef(unsafe.Pointer(&ptr1))
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *kinc_g4_pipeline) Ref() *C.kinc_g4_pipeline_t {
	if x == nil {
		return nil
	}
	return x.refbc4f930f
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *kinc_g4_pipeline) Free() {
	if x != nil && x.allocsbc4f930f != nil {
		x.allocsbc4f930f.(*cgoAllocMap).Free()
		x.refbc4f930f = nil
	}
}

// Newkinc_g4_pipelineRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func Newkinc_g4_pipelineRef(ref unsafe.Pointer) *kinc_g4_pipeline {
	if ref == nil {
		return nil
	}
	obj := new(kinc_g4_pipeline)
	obj.refbc4f930f = (*C.kinc_g4_pipeline_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *kinc_g4_pipeline) PassRef() (*C.kinc_g4_pipeline_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refbc4f930f != nil {
		return x.refbc4f930f, nil
	}
	membc4f930f := allocKinc_g4_pipelineMemory(1)
	refbc4f930f := (*C.kinc_g4_pipeline_t)(membc4f930f)
	allocsbc4f930f := new(cgoAllocMap)
	allocsbc4f930f.Add(membc4f930f)

	var cinput_layout_allocs *cgoAllocMap
	refbc4f930f.input_layout, cinput_layout_allocs = unpackA16PKinc_g4_vertex_structure(x.input_layout)
	allocsbc4f930f.Borrow(cinput_layout_allocs)

	var cvertex_shader_allocs *cgoAllocMap
	refbc4f930f.vertex_shader, cvertex_shader_allocs = x.vertex_shader.PassRef() //unpackSKinc_g4_shader(x.vertex_shader)
	allocsbc4f930f.Borrow(cvertex_shader_allocs)

	var cfragment_shader_allocs *cgoAllocMap
	refbc4f930f.fragment_shader, cfragment_shader_allocs = x.fragment_shader.PassRef() //unpackSKinc_g4_shader(x.fragment_shader)
	allocsbc4f930f.Borrow(cfragment_shader_allocs)

	var cgeometry_shader_allocs *cgoAllocMap
	refbc4f930f.geometry_shader, cgeometry_shader_allocs = x.geometry_shader.PassRef() // unpackSKinc_g4_shader(x.geometry_shader)
	allocsbc4f930f.Borrow(cgeometry_shader_allocs)

	var ctessellation_control_shader_allocs *cgoAllocMap
	refbc4f930f.tessellation_control_shader, ctessellation_control_shader_allocs = x.tessellation_control_shader.PassRef() //unpackSKinc_g4_shader(x.tessellation_control_shader)
	allocsbc4f930f.Borrow(ctessellation_control_shader_allocs)

	var ctessellation_evaluation_shader_allocs *cgoAllocMap
	refbc4f930f.tessellation_evaluation_shader, ctessellation_evaluation_shader_allocs = x.tessellation_evaluation_shader.PassRef() // unpackSKinc_g4_shader(x.tessellation_evaluation_shader)
	allocsbc4f930f.Borrow(ctessellation_evaluation_shader_allocs)

	var ccull_mode_allocs *cgoAllocMap
	refbc4f930f.cull_mode, ccull_mode_allocs = (C.kinc_g4_cull_mode_t)(x.cull_mode), cgoAllocsUnknown
	allocsbc4f930f.Borrow(ccull_mode_allocs)

	var cdepth_write_allocs *cgoAllocMap
	refbc4f930f.depth_write, cdepth_write_allocs = (C._Bool)(x.depth_write), cgoAllocsUnknown
	allocsbc4f930f.Borrow(cdepth_write_allocs)

	var cdepth_mode_allocs *cgoAllocMap
	refbc4f930f.depth_mode, cdepth_mode_allocs = (C.kinc_g4_compare_mode_t)(x.depth_mode), cgoAllocsUnknown
	allocsbc4f930f.Borrow(cdepth_mode_allocs)

	var cstencil_mode_allocs *cgoAllocMap
	refbc4f930f.stencil_mode, cstencil_mode_allocs = (C.kinc_g4_compare_mode_t)(x.stencil_mode), cgoAllocsUnknown
	allocsbc4f930f.Borrow(cstencil_mode_allocs)

	var cstencil_both_pass_allocs *cgoAllocMap
	refbc4f930f.stencil_both_pass, cstencil_both_pass_allocs = (C.kinc_g4_stencil_action_t)(x.stencil_both_pass), cgoAllocsUnknown
	allocsbc4f930f.Borrow(cstencil_both_pass_allocs)

	var cstencil_depth_fail_allocs *cgoAllocMap
	refbc4f930f.stencil_depth_fail, cstencil_depth_fail_allocs = (C.kinc_g4_stencil_action_t)(x.stencil_depth_fail), cgoAllocsUnknown
	allocsbc4f930f.Borrow(cstencil_depth_fail_allocs)

	var cstencil_fail_allocs *cgoAllocMap
	refbc4f930f.stencil_fail, cstencil_fail_allocs = (C.kinc_g4_stencil_action_t)(x.stencil_fail), cgoAllocsUnknown
	allocsbc4f930f.Borrow(cstencil_fail_allocs)

	var cstencil_reference_value_allocs *cgoAllocMap
	refbc4f930f.stencil_reference_value, cstencil_reference_value_allocs = (C.int)(x.stencil_reference_value), cgoAllocsUnknown
	allocsbc4f930f.Borrow(cstencil_reference_value_allocs)

	var cstencil_read_mask_allocs *cgoAllocMap
	refbc4f930f.stencil_read_mask, cstencil_read_mask_allocs = (C.int)(x.stencil_read_mask), cgoAllocsUnknown
	allocsbc4f930f.Borrow(cstencil_read_mask_allocs)

	var cstencil_write_mask_allocs *cgoAllocMap
	refbc4f930f.stencil_write_mask, cstencil_write_mask_allocs = (C.int)(x.stencil_write_mask), cgoAllocsUnknown
	allocsbc4f930f.Borrow(cstencil_write_mask_allocs)

	var cblend_source_allocs *cgoAllocMap
	refbc4f930f.blend_source, cblend_source_allocs = (C.kinc_g4_blending_operation_t)(x.blend_source), cgoAllocsUnknown
	allocsbc4f930f.Borrow(cblend_source_allocs)

	var cblend_destination_allocs *cgoAllocMap
	refbc4f930f.blend_destination, cblend_destination_allocs = (C.kinc_g4_blending_operation_t)(x.blend_destination), cgoAllocsUnknown
	allocsbc4f930f.Borrow(cblend_destination_allocs)

	var calpha_blend_source_allocs *cgoAllocMap
	refbc4f930f.alpha_blend_source, calpha_blend_source_allocs = (C.kinc_g4_blending_operation_t)(x.alpha_blend_source), cgoAllocsUnknown
	allocsbc4f930f.Borrow(calpha_blend_source_allocs)

	var calpha_blend_destination_allocs *cgoAllocMap
	refbc4f930f.alpha_blend_destination, calpha_blend_destination_allocs = (C.kinc_g4_blending_operation_t)(x.alpha_blend_destination), cgoAllocsUnknown
	allocsbc4f930f.Borrow(calpha_blend_destination_allocs)

	var ccolor_write_mask_red_allocs *cgoAllocMap
	refbc4f930f.color_write_mask_red, ccolor_write_mask_red_allocs = *(*[8]C._Bool)(unsafe.Pointer(&x.color_write_mask_red)), cgoAllocsUnknown
	allocsbc4f930f.Borrow(ccolor_write_mask_red_allocs)

	var ccolor_write_mask_green_allocs *cgoAllocMap
	refbc4f930f.color_write_mask_green, ccolor_write_mask_green_allocs = *(*[8]C._Bool)(unsafe.Pointer(&x.color_write_mask_green)), cgoAllocsUnknown
	allocsbc4f930f.Borrow(ccolor_write_mask_green_allocs)

	var ccolor_write_mask_blue_allocs *cgoAllocMap
	refbc4f930f.color_write_mask_blue, ccolor_write_mask_blue_allocs = *(*[8]C._Bool)(unsafe.Pointer(&x.color_write_mask_blue)), cgoAllocsUnknown
	allocsbc4f930f.Borrow(ccolor_write_mask_blue_allocs)

	var ccolor_write_mask_alpha_allocs *cgoAllocMap
	refbc4f930f.color_write_mask_alpha, ccolor_write_mask_alpha_allocs = *(*[8]C._Bool)(unsafe.Pointer(&x.color_write_mask_alpha)), cgoAllocsUnknown
	allocsbc4f930f.Borrow(ccolor_write_mask_alpha_allocs)

	var cconservative_rasterization_allocs *cgoAllocMap
	refbc4f930f.conservative_rasterization, cconservative_rasterization_allocs = (C._Bool)(x.conservative_rasterization), cgoAllocsUnknown
	allocsbc4f930f.Borrow(cconservative_rasterization_allocs)

	var cimpl_allocs *cgoAllocMap
	refbc4f930f.impl, cimpl_allocs = x.impl.PassValue()
	allocsbc4f930f.Borrow(cimpl_allocs)

	x.refbc4f930f = refbc4f930f
	x.allocsbc4f930f = allocsbc4f930f
	return refbc4f930f, allocsbc4f930f

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x kinc_g4_pipeline) PassValue() (C.kinc_g4_pipeline_t, *cgoAllocMap) {
	if x.refbc4f930f != nil {
		return *x.refbc4f930f, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *kinc_g4_pipeline) Deref() {
	if x.refbc4f930f == nil {
		return
	}
	packA16PKinc_g4_vertex_structure(&x.input_layout, (*[16]*C.struct_kinc_g4_vertex_structure)(unsafe.Pointer(&x.refbc4f930f.input_layout)))
	// packSKinc_g4_shader(x.vertex_shader, x.refbc4f930f.vertex_shader)
	// packSKinc_g4_shader(x.fragment_shader, x.refbc4f930f.fragment_shader)
	// packSKinc_g4_shader(x.geometry_shader, x.refbc4f930f.geometry_shader)
	// packSKinc_g4_shader(x.tessellation_control_shader, x.refbc4f930f.tessellation_control_shader)
	// packSKinc_g4_shader(x.tessellation_evaluation_shader, x.refbc4f930f.tessellation_evaluation_shader)
	x.vertex_shader = (*kinc_g4_shader)(unsafe.Pointer(x.refbc4f930f.vertex_shader))
	x.fragment_shader = (*kinc_g4_shader)(unsafe.Pointer(x.refbc4f930f.fragment_shader))
	x.geometry_shader = (*kinc_g4_shader)(unsafe.Pointer(x.refbc4f930f.geometry_shader))
	x.tessellation_control_shader = (*kinc_g4_shader)(unsafe.Pointer(x.refbc4f930f.tessellation_control_shader))
	x.tessellation_evaluation_shader = (*kinc_g4_shader)(unsafe.Pointer(x.refbc4f930f.tessellation_evaluation_shader))
	x.cull_mode = (kinc_g4_cull_mode)(x.refbc4f930f.cull_mode)
	x.depth_write = (bool)(x.refbc4f930f.depth_write)
	x.depth_mode = (kinc_g4_compare_mode)(x.refbc4f930f.depth_mode)
	x.stencil_mode = (kinc_g4_compare_mode)(x.refbc4f930f.stencil_mode)
	x.stencil_both_pass = (kinc_g4_stencil_action)(x.refbc4f930f.stencil_both_pass)
	x.stencil_depth_fail = (kinc_g4_stencil_action)(x.refbc4f930f.stencil_depth_fail)
	x.stencil_fail = (kinc_g4_stencil_action)(x.refbc4f930f.stencil_fail)
	x.stencil_reference_value = (int32)(x.refbc4f930f.stencil_reference_value)
	x.stencil_read_mask = (int32)(x.refbc4f930f.stencil_read_mask)
	x.stencil_write_mask = (int32)(x.refbc4f930f.stencil_write_mask)
	x.blend_source = (kinc_g4_blending_operation)(x.refbc4f930f.blend_source)
	x.blend_destination = (kinc_g4_blending_operation)(x.refbc4f930f.blend_destination)
	x.alpha_blend_source = (kinc_g4_blending_operation)(x.refbc4f930f.alpha_blend_source)
	x.alpha_blend_destination = (kinc_g4_blending_operation)(x.refbc4f930f.alpha_blend_destination)
	x.color_write_mask_red = *(*[8]bool)(unsafe.Pointer(&x.refbc4f930f.color_write_mask_red))
	x.color_write_mask_green = *(*[8]bool)(unsafe.Pointer(&x.refbc4f930f.color_write_mask_green))
	x.color_write_mask_blue = *(*[8]bool)(unsafe.Pointer(&x.refbc4f930f.color_write_mask_blue))
	x.color_write_mask_alpha = *(*[8]bool)(unsafe.Pointer(&x.refbc4f930f.color_write_mask_alpha))
	x.conservative_rasterization = (bool)(x.refbc4f930f.conservative_rasterization)
	x.impl = *Newkinc_g4_pipeline_implRef(unsafe.Pointer(&x.refbc4f930f.impl))
}

// allocKinc_g4_render_targetMemory allocates memory for type C.kinc_g4_render_target_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocKinc_g4_render_targetMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfKinc_g4_render_targetValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfKinc_g4_render_targetValue = unsafe.Sizeof([1]C.kinc_g4_render_target_t{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *kinc_g4_render_target) Ref() *C.kinc_g4_render_target_t {
	if x == nil {
		return nil
	}
	return x.ref9202c784
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *kinc_g4_render_target) Free() {
	if x != nil && x.allocs9202c784 != nil {
		x.allocs9202c784.(*cgoAllocMap).Free()
		x.ref9202c784 = nil
	}
}

// Newkinc_g4_render_targetRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func Newkinc_g4_render_targetRef(ref unsafe.Pointer) *kinc_g4_render_target {
	if ref == nil {
		return nil
	}
	obj := new(kinc_g4_render_target)
	obj.ref9202c784 = (*C.kinc_g4_render_target_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *kinc_g4_render_target) PassRef() (*C.kinc_g4_render_target_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref9202c784 != nil {
		return x.ref9202c784, nil
	}
	mem9202c784 := allocKinc_g4_render_targetMemory(1)
	ref9202c784 := (*C.kinc_g4_render_target_t)(mem9202c784)
	allocs9202c784 := new(cgoAllocMap)
	allocs9202c784.Add(mem9202c784)

	var cwidth_allocs *cgoAllocMap
	ref9202c784.width, cwidth_allocs = (C.int)(x.width), cgoAllocsUnknown
	allocs9202c784.Borrow(cwidth_allocs)

	var cheight_allocs *cgoAllocMap
	ref9202c784.height, cheight_allocs = (C.int)(x.height), cgoAllocsUnknown
	allocs9202c784.Borrow(cheight_allocs)

	var ctexWidth_allocs *cgoAllocMap
	ref9202c784.texWidth, ctexWidth_allocs = (C.int)(x.texwidth), cgoAllocsUnknown
	allocs9202c784.Borrow(ctexWidth_allocs)

	var ctexHeight_allocs *cgoAllocMap
	ref9202c784.texHeight, ctexHeight_allocs = (C.int)(x.texheight), cgoAllocsUnknown
	allocs9202c784.Borrow(ctexHeight_allocs)

	var ccontextId_allocs *cgoAllocMap
	ref9202c784.contextId, ccontextId_allocs = (C.int)(x.contextid), cgoAllocsUnknown
	allocs9202c784.Borrow(ccontextId_allocs)

	var cisCubeMap_allocs *cgoAllocMap
	ref9202c784.isCubeMap, cisCubeMap_allocs = (C._Bool)(x.iscubemap), cgoAllocsUnknown
	allocs9202c784.Borrow(cisCubeMap_allocs)

	var cisDepthAttachment_allocs *cgoAllocMap
	ref9202c784.isDepthAttachment, cisDepthAttachment_allocs = (C._Bool)(x.isdepthattachment), cgoAllocsUnknown
	allocs9202c784.Borrow(cisDepthAttachment_allocs)

	var cimpl_allocs *cgoAllocMap
	ref9202c784.impl, cimpl_allocs = x.impl.PassValue()
	allocs9202c784.Borrow(cimpl_allocs)

	x.ref9202c784 = ref9202c784
	x.allocs9202c784 = allocs9202c784
	return ref9202c784, allocs9202c784

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x kinc_g4_render_target) PassValue() (C.kinc_g4_render_target_t, *cgoAllocMap) {
	if x.ref9202c784 != nil {
		return *x.ref9202c784, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *kinc_g4_render_target) Deref() {
	if x.ref9202c784 == nil {
		return
	}
	x.width = (int32)(x.ref9202c784.width)
	x.height = (int32)(x.ref9202c784.height)
	x.texwidth = (int32)(x.ref9202c784.texWidth)
	x.texheight = (int32)(x.ref9202c784.texHeight)
	x.contextid = (int32)(x.ref9202c784.contextId)
	x.iscubemap = (bool)(x.ref9202c784.isCubeMap)
	x.isdepthattachment = (bool)(x.ref9202c784.isDepthAttachment)
	x.impl = *Newkinc_g4_render_target_implRef(unsafe.Pointer(&x.ref9202c784.impl))
}

// allocKinc_g4_render_target_implMemory allocates memory for type C.kinc_g4_render_target_impl_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocKinc_g4_render_target_implMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfKinc_g4_render_target_implValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfKinc_g4_render_target_implValue = unsafe.Sizeof([1]C.kinc_g4_render_target_impl_t{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *kinc_g4_render_target_impl) Ref() *C.kinc_g4_render_target_impl_t {
	if x == nil {
		return nil
	}
	return x.refb77ecfd9
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *kinc_g4_render_target_impl) Free() {
	if x != nil && x.allocsb77ecfd9 != nil {
		x.allocsb77ecfd9.(*cgoAllocMap).Free()
		x.refb77ecfd9 = nil
	}
}

// Newkinc_g4_render_target_implRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func Newkinc_g4_render_target_implRef(ref unsafe.Pointer) *kinc_g4_render_target_impl {
	if ref == nil {
		return nil
	}
	obj := new(kinc_g4_render_target_impl)
	obj.refb77ecfd9 = (*C.kinc_g4_render_target_impl_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *kinc_g4_render_target_impl) PassRef() (*C.kinc_g4_render_target_impl_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refb77ecfd9 != nil {
		return x.refb77ecfd9, nil
	}
	memb77ecfd9 := allocKinc_g4_render_target_implMemory(1)
	refb77ecfd9 := (*C.kinc_g4_render_target_impl_t)(memb77ecfd9)
	allocsb77ecfd9 := new(cgoAllocMap)
	allocsb77ecfd9.Add(memb77ecfd9)

	var c_framebuffer_allocs *cgoAllocMap
	refb77ecfd9._framebuffer, c_framebuffer_allocs = (C.uint)(x._framebuffer), cgoAllocsUnknown
	allocsb77ecfd9.Borrow(c_framebuffer_allocs)

	var c_texture_allocs *cgoAllocMap
	refb77ecfd9._texture, c_texture_allocs = (C.uint)(x._texture), cgoAllocsUnknown
	allocsb77ecfd9.Borrow(c_texture_allocs)

	var c_depthTexture_allocs *cgoAllocMap
	refb77ecfd9._depthTexture, c_depthTexture_allocs = (C.uint)(x._depthtexture), cgoAllocsUnknown
	allocsb77ecfd9.Borrow(c_depthTexture_allocs)

	var c_hasDepth_allocs *cgoAllocMap
	refb77ecfd9._hasDepth, c_hasDepth_allocs = (C._Bool)(x._hasdepth), cgoAllocsUnknown
	allocsb77ecfd9.Borrow(c_hasDepth_allocs)

	var ccontextId_allocs *cgoAllocMap
	refb77ecfd9.contextId, ccontextId_allocs = (C.int)(x.contextid), cgoAllocsUnknown
	allocsb77ecfd9.Borrow(ccontextId_allocs)

	var cformat_allocs *cgoAllocMap
	refb77ecfd9.format, cformat_allocs = (C.int)(x.format), cgoAllocsUnknown
	allocsb77ecfd9.Borrow(cformat_allocs)

	x.refb77ecfd9 = refb77ecfd9
	x.allocsb77ecfd9 = allocsb77ecfd9
	return refb77ecfd9, allocsb77ecfd9

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x kinc_g4_render_target_impl) PassValue() (C.kinc_g4_render_target_impl_t, *cgoAllocMap) {
	if x.refb77ecfd9 != nil {
		return *x.refb77ecfd9, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *kinc_g4_render_target_impl) Deref() {
	if x.refb77ecfd9 == nil {
		return
	}
	x._framebuffer = (uint32)(x.refb77ecfd9._framebuffer)
	x._texture = (uint32)(x.refb77ecfd9._texture)
	x._depthtexture = (uint32)(x.refb77ecfd9._depthTexture)
	x._hasdepth = (bool)(x.refb77ecfd9._hasDepth)
	x.contextid = (int32)(x.refb77ecfd9.contextId)
	x.format = (int32)(x.refb77ecfd9.format)
}

// allocKinc_g4_shaderMemory allocates memory for type C.kinc_g4_shader_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocKinc_g4_shaderMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfKinc_g4_shaderValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfKinc_g4_shaderValue = unsafe.Sizeof([1]C.kinc_g4_shader_t{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *kinc_g4_shader) Ref() *C.kinc_g4_shader_t {
	if x == nil {
		return nil
	}
	return x.refb0bbefcb
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *kinc_g4_shader) Free() {
	if x != nil && x.allocsb0bbefcb != nil {
		x.allocsb0bbefcb.(*cgoAllocMap).Free()
		x.refb0bbefcb = nil
	}
}

// Newkinc_g4_shaderRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func Newkinc_g4_shaderRef(ref unsafe.Pointer) *kinc_g4_shader {
	if ref == nil {
		return nil
	}
	obj := new(kinc_g4_shader)
	obj.refb0bbefcb = (*C.kinc_g4_shader_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *kinc_g4_shader) PassRef() (*C.kinc_g4_shader_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refb0bbefcb != nil {
		return x.refb0bbefcb, nil
	}
	memb0bbefcb := allocKinc_g4_shaderMemory(1)
	refb0bbefcb := (*C.kinc_g4_shader_t)(memb0bbefcb)
	allocsb0bbefcb := new(cgoAllocMap)
	allocsb0bbefcb.Add(memb0bbefcb)

	var cimpl_allocs *cgoAllocMap
	refb0bbefcb.impl, cimpl_allocs = x.impl.PassValue()
	allocsb0bbefcb.Borrow(cimpl_allocs)

	x.refb0bbefcb = refb0bbefcb
	x.allocsb0bbefcb = allocsb0bbefcb
	return refb0bbefcb, allocsb0bbefcb

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x kinc_g4_shader) PassValue() (C.kinc_g4_shader_t, *cgoAllocMap) {
	if x.refb0bbefcb != nil {
		return *x.refb0bbefcb, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *kinc_g4_shader) Deref() {
	if x.refb0bbefcb == nil {
		return
	}
	x.impl = *Newkinc_g4_shader_implRef(unsafe.Pointer(&x.refb0bbefcb.impl))
}

// allocKinc_g4_texture_array_implMemory allocates memory for type C.kinc_g4_texture_array_impl_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocKinc_g4_texture_array_implMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfKinc_g4_texture_array_implValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfKinc_g4_texture_array_implValue = unsafe.Sizeof([1]C.kinc_g4_texture_array_impl_t{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *kinc_g4_texture_array_impl) Ref() *C.kinc_g4_texture_array_impl_t {
	if x == nil {
		return nil
	}
	return x.refc8cc717a
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *kinc_g4_texture_array_impl) Free() {
	if x != nil && x.allocsc8cc717a != nil {
		x.allocsc8cc717a.(*cgoAllocMap).Free()
		x.refc8cc717a = nil
	}
}

// Newkinc_g4_texture_array_implRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func Newkinc_g4_texture_array_implRef(ref unsafe.Pointer) *kinc_g4_texture_array_impl {
	if ref == nil {
		return nil
	}
	obj := new(kinc_g4_texture_array_impl)
	obj.refc8cc717a = (*C.kinc_g4_texture_array_impl_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *kinc_g4_texture_array_impl) PassRef() (*C.kinc_g4_texture_array_impl_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refc8cc717a != nil {
		return x.refc8cc717a, nil
	}
	memc8cc717a := allocKinc_g4_texture_array_implMemory(1)
	refc8cc717a := (*C.kinc_g4_texture_array_impl_t)(memc8cc717a)
	allocsc8cc717a := new(cgoAllocMap)
	allocsc8cc717a.Add(memc8cc717a)

	var ctexture_allocs *cgoAllocMap
	refc8cc717a.texture, ctexture_allocs = (C.uint)(x.texture), cgoAllocsUnknown
	allocsc8cc717a.Borrow(ctexture_allocs)

	x.refc8cc717a = refc8cc717a
	x.allocsc8cc717a = allocsc8cc717a
	return refc8cc717a, allocsc8cc717a

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x kinc_g4_texture_array_impl) PassValue() (C.kinc_g4_texture_array_impl_t, *cgoAllocMap) {
	if x.refc8cc717a != nil {
		return *x.refc8cc717a, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *kinc_g4_texture_array_impl) Deref() {
	if x.refc8cc717a == nil {
		return
	}
	x.texture = (uint32)(x.refc8cc717a.texture)
}

// allocKinc_compute_constant_location_implMemory allocates memory for type C.kinc_compute_constant_location_impl_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocKinc_compute_constant_location_implMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfKinc_compute_constant_location_implValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfKinc_compute_constant_location_implValue = unsafe.Sizeof([1]C.kinc_compute_constant_location_impl_t{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *kinc_compute_constant_location_impl) Ref() *C.kinc_compute_constant_location_impl_t {
	if x == nil {
		return nil
	}
	return x.ref53dfa078
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *kinc_compute_constant_location_impl) Free() {
	if x != nil && x.allocs53dfa078 != nil {
		x.allocs53dfa078.(*cgoAllocMap).Free()
		x.ref53dfa078 = nil
	}
}

// Newkinc_compute_constant_location_implRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func Newkinc_compute_constant_location_implRef(ref unsafe.Pointer) *kinc_compute_constant_location_impl {
	if ref == nil {
		return nil
	}
	obj := new(kinc_compute_constant_location_impl)
	obj.ref53dfa078 = (*C.kinc_compute_constant_location_impl_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *kinc_compute_constant_location_impl) PassRef() (*C.kinc_compute_constant_location_impl_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref53dfa078 != nil {
		return x.ref53dfa078, nil
	}
	mem53dfa078 := allocKinc_compute_constant_location_implMemory(1)
	ref53dfa078 := (*C.kinc_compute_constant_location_impl_t)(mem53dfa078)
	allocs53dfa078 := new(cgoAllocMap)
	allocs53dfa078.Add(mem53dfa078)

	var clocation_allocs *cgoAllocMap
	ref53dfa078.location, clocation_allocs = (C.int)(x.location), cgoAllocsUnknown
	allocs53dfa078.Borrow(clocation_allocs)

	var c_type_allocs *cgoAllocMap
	ref53dfa078._type, c_type_allocs = (C.uint)(x._type), cgoAllocsUnknown
	allocs53dfa078.Borrow(c_type_allocs)

	x.ref53dfa078 = ref53dfa078
	x.allocs53dfa078 = allocs53dfa078
	return ref53dfa078, allocs53dfa078

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x kinc_compute_constant_location_impl) PassValue() (C.kinc_compute_constant_location_impl_t, *cgoAllocMap) {
	if x.ref53dfa078 != nil {
		return *x.ref53dfa078, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *kinc_compute_constant_location_impl) Deref() {
	if x.ref53dfa078 == nil {
		return
	}
	x.location = (int32)(x.ref53dfa078.location)
	x._type = (uint32)(x.ref53dfa078._type)
}

// allocKinc_compute_texture_unit_implMemory allocates memory for type C.kinc_compute_texture_unit_impl_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocKinc_compute_texture_unit_implMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfKinc_compute_texture_unit_implValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfKinc_compute_texture_unit_implValue = unsafe.Sizeof([1]C.kinc_compute_texture_unit_impl_t{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *kinc_compute_texture_unit_impl) Ref() *C.kinc_compute_texture_unit_impl_t {
	if x == nil {
		return nil
	}
	return x.refdc23bd2a
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *kinc_compute_texture_unit_impl) Free() {
	if x != nil && x.allocsdc23bd2a != nil {
		x.allocsdc23bd2a.(*cgoAllocMap).Free()
		x.refdc23bd2a = nil
	}
}

// Newkinc_compute_texture_unit_implRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func Newkinc_compute_texture_unit_implRef(ref unsafe.Pointer) *kinc_compute_texture_unit_impl {
	if ref == nil {
		return nil
	}
	obj := new(kinc_compute_texture_unit_impl)
	obj.refdc23bd2a = (*C.kinc_compute_texture_unit_impl_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *kinc_compute_texture_unit_impl) PassRef() (*C.kinc_compute_texture_unit_impl_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refdc23bd2a != nil {
		return x.refdc23bd2a, nil
	}
	memdc23bd2a := allocKinc_compute_texture_unit_implMemory(1)
	refdc23bd2a := (*C.kinc_compute_texture_unit_impl_t)(memdc23bd2a)
	allocsdc23bd2a := new(cgoAllocMap)
	allocsdc23bd2a.Add(memdc23bd2a)

	var cunit_allocs *cgoAllocMap
	refdc23bd2a.unit, cunit_allocs = (C.int)(x.unit), cgoAllocsUnknown
	allocsdc23bd2a.Borrow(cunit_allocs)

	x.refdc23bd2a = refdc23bd2a
	x.allocsdc23bd2a = allocsdc23bd2a
	return refdc23bd2a, allocsdc23bd2a

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x kinc_compute_texture_unit_impl) PassValue() (C.kinc_compute_texture_unit_impl_t, *cgoAllocMap) {
	if x.refdc23bd2a != nil {
		return *x.refdc23bd2a, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *kinc_compute_texture_unit_impl) Deref() {
	if x.refdc23bd2a == nil {
		return
	}
	x.unit = (int32)(x.refdc23bd2a.unit)
}

// allocKinc_compute_shader_implMemory allocates memory for type C.kinc_compute_shader_impl_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocKinc_compute_shader_implMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfKinc_compute_shader_implValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfKinc_compute_shader_implValue = unsafe.Sizeof([1]C.kinc_compute_shader_impl_t{})

// copyPCharBytes copies the data from Go slice as *C.char.
func copyPCharBytes(slice *sliceHeader) (*C.char, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfCharValue) * slice.Len,
		Cap:  int(sizeOfCharValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.char)(mem0), allocs
}

// allocCharMemory allocates memory for type C.char in C.
// The caller is responsible for freeing the this memory via C.free.
func allocCharMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfCharValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfCharValue = unsafe.Sizeof([1]C.char{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *kinc_compute_shader_impl) Ref() *C.kinc_compute_shader_impl_t {
	if x == nil {
		return nil
	}
	return x.refb30f42cb
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *kinc_compute_shader_impl) Free() {
	if x != nil && x.allocsb30f42cb != nil {
		x.allocsb30f42cb.(*cgoAllocMap).Free()
		x.refb30f42cb = nil
	}
}

// Newkinc_compute_shader_implRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func Newkinc_compute_shader_implRef(ref unsafe.Pointer) *kinc_compute_shader_impl {
	if ref == nil {
		return nil
	}
	obj := new(kinc_compute_shader_impl)
	obj.refb30f42cb = (*C.kinc_compute_shader_impl_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *kinc_compute_shader_impl) PassRef() (*C.kinc_compute_shader_impl_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refb30f42cb != nil {
		return x.refb30f42cb, nil
	}
	memb30f42cb := allocKinc_compute_shader_implMemory(1)
	refb30f42cb := (*C.kinc_compute_shader_impl_t)(memb30f42cb)
	allocsb30f42cb := new(cgoAllocMap)
	allocsb30f42cb.Add(memb30f42cb)

	var ctextures_allocs *cgoAllocMap
	refb30f42cb.textures, ctextures_allocs = unpackSSByte(x.textures)
	allocsb30f42cb.Borrow(ctextures_allocs)

	var ctextureValues_allocs *cgoAllocMap
	refb30f42cb.textureValues, ctextureValues_allocs = copyPIntBytes((*sliceHeader)(unsafe.Pointer(&x.texturevalues)))
	allocsb30f42cb.Borrow(ctextureValues_allocs)

	var ctextureCount_allocs *cgoAllocMap
	refb30f42cb.textureCount, ctextureCount_allocs = (C.int)(x.texturecount), cgoAllocsUnknown
	allocsb30f42cb.Borrow(ctextureCount_allocs)

	var c_id_allocs *cgoAllocMap
	refb30f42cb._id, c_id_allocs = (C.uint)(x._id), cgoAllocsUnknown
	allocsb30f42cb.Borrow(c_id_allocs)

	var c_programid_allocs *cgoAllocMap
	refb30f42cb._programid, c_programid_allocs = (C.uint)(x._programid), cgoAllocsUnknown
	allocsb30f42cb.Borrow(c_programid_allocs)

	var c_source_allocs *cgoAllocMap
	refb30f42cb._source, c_source_allocs = copyPCharBytes((*sliceHeader)(unsafe.Pointer(&x._source)))
	allocsb30f42cb.Borrow(c_source_allocs)

	var c_length_allocs *cgoAllocMap
	refb30f42cb._length, c_length_allocs = (C.int)(x._length), cgoAllocsUnknown
	allocsb30f42cb.Borrow(c_length_allocs)

	x.refb30f42cb = refb30f42cb
	x.allocsb30f42cb = allocsb30f42cb
	return refb30f42cb, allocsb30f42cb

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x kinc_compute_shader_impl) PassValue() (C.kinc_compute_shader_impl_t, *cgoAllocMap) {
	if x.refb30f42cb != nil {
		return *x.refb30f42cb, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *kinc_compute_shader_impl) Deref() {
	if x.refb30f42cb == nil {
		return
	}
	packSSByte(x.textures, x.refb30f42cb.textures)
	hxf0d18b7 := (*sliceHeader)(unsafe.Pointer(&x.texturevalues))
	hxf0d18b7.Data = unsafe.Pointer(x.refb30f42cb.textureValues)
	hxf0d18b7.Cap = 0x7fffffff
	// hxf0d18b7.Len = ?

	x.texturecount = (int32)(x.refb30f42cb.textureCount)
	x._id = (uint32)(x.refb30f42cb._id)
	x._programid = (uint32)(x.refb30f42cb._programid)
	hxf2fab0d := (*sliceHeader)(unsafe.Pointer(&x._source))
	hxf2fab0d.Data = unsafe.Pointer(x.refb30f42cb._source)
	hxf2fab0d.Cap = 0x7fffffff
	// hxf2fab0d.Len = ?

	x._length = (int32)(x.refb30f42cb._length)
}

// allocKinc_float32x4Memory allocates memory for type C.kinc_float32x4_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocKinc_float32x4Memory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfKinc_float32x4Value))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfKinc_float32x4Value = unsafe.Sizeof([1]C.kinc_float32x4_t{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *kinc_float32x4) Ref() *C.kinc_float32x4_t {
	if x == nil {
		return nil
	}
	return x.ref4b561b2e
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *kinc_float32x4) Free() {
	if x != nil && x.allocs4b561b2e != nil {
		x.allocs4b561b2e.(*cgoAllocMap).Free()
		x.ref4b561b2e = nil
	}
}

// Newkinc_float32x4Ref creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func Newkinc_float32x4Ref(ref unsafe.Pointer) *kinc_float32x4 {
	if ref == nil {
		return nil
	}
	obj := new(kinc_float32x4)
	obj.ref4b561b2e = (*C.kinc_float32x4_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *kinc_float32x4) PassRef() (*C.kinc_float32x4_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref4b561b2e != nil {
		return x.ref4b561b2e, nil
	}
	mem4b561b2e := allocKinc_float32x4Memory(1)
	ref4b561b2e := (*C.kinc_float32x4_t)(mem4b561b2e)
	allocs4b561b2e := new(cgoAllocMap)
	allocs4b561b2e.Add(mem4b561b2e)

	var cvalues_allocs *cgoAllocMap
	ref4b561b2e.values, cvalues_allocs = *(*[4]C.float)(unsafe.Pointer(&x.values)), cgoAllocsUnknown
	allocs4b561b2e.Borrow(cvalues_allocs)

	x.ref4b561b2e = ref4b561b2e
	x.allocs4b561b2e = allocs4b561b2e
	return ref4b561b2e, allocs4b561b2e

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x kinc_float32x4) PassValue() (C.kinc_float32x4_t, *cgoAllocMap) {
	if x.ref4b561b2e != nil {
		return *x.ref4b561b2e, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *kinc_float32x4) Deref() {
	if x.ref4b561b2e == nil {
		return
	}
	x.values = *(*[4]float32)(unsafe.Pointer(&x.ref4b561b2e.values))
}

// unpackArgSKinc_image transforms a sliced Go data structure into plain C format.
func unpackArgSKinc_image(x []kinc_image) (unpacked *C.kinc_image_t, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocKinc_imageMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.kinc_image_t)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.kinc_image_t)(h.Data)
	return
}

// packSKinc_image reads sliced Go data structure out from plain C format.
func packSKinc_image(v []kinc_image, ptr0 *C.kinc_image_t) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfKinc_imageValue]C.kinc_image_t)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *Newkinc_imageRef(unsafe.Pointer(&ptr1))
	}
}

// allocPKinc_g4_vertex_bufferMemory allocates memory for type *C.kinc_g4_vertex_buffer_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPKinc_g4_vertex_bufferMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPKinc_g4_vertex_bufferValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPKinc_g4_vertex_bufferValue = unsafe.Sizeof([1]*C.kinc_g4_vertex_buffer_t{})

// unpackArgSPKinc_g4_vertex_buffer transforms a sliced Go data structure into plain C format.
func unpackArgSPKinc_g4_vertex_buffer(x []*kinc_g4_vertex_buffer) (unpacked **C.kinc_g4_vertex_buffer_t, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocPKinc_g4_vertex_bufferMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]*C.kinc_g4_vertex_buffer_t)(unsafe.Pointer(h0))
	for i0 := range x {
		v0[i0], _ = x[i0].PassRef()
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (**C.kinc_g4_vertex_buffer_t)(h.Data)
	return
}

// packSPKinc_g4_vertex_buffer reads sliced Go data structure out from plain C format.
func packSPKinc_g4_vertex_buffer(v []*kinc_g4_vertex_buffer, ptr0 **C.kinc_g4_vertex_buffer_t) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPtr]*C.kinc_g4_vertex_buffer_t)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = Newkinc_g4_vertex_bufferRef(unsafe.Pointer(ptr1))
	}
}

// copyPUint8Bytes copies the data from Go slice as *C.uint8_t.
func copyPUint8Bytes(slice *sliceHeader) (*C.uint8_t, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfUint8Value) * slice.Len,
		Cap:  int(sizeOfUint8Value) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.uint8_t)(mem0), allocs
}

// allocUint8Memory allocates memory for type C.uint8_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocUint8Memory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfUint8Value))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfUint8Value = unsafe.Sizeof([1]C.uint8_t{})

// copyPWcharBytes copies the data from Go slice as *C.wchar_t.
func copyPWcharBytes(slice *sliceHeader) (*C.wchar_t, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfWcharValue) * slice.Len,
		Cap:  int(sizeOfWcharValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.wchar_t)(mem0), allocs
}

// allocWcharMemory allocates memory for type C.wchar_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocWcharMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfWcharValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfWcharValue = unsafe.Sizeof([1]C.wchar_t{})

// allocPStruct_kinc_g4_render_targetMemory allocates memory for type *C.struct_kinc_g4_render_target in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPStruct_kinc_g4_render_targetMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPStruct_kinc_g4_render_targetValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPStruct_kinc_g4_render_targetValue = unsafe.Sizeof([1]*C.struct_kinc_g4_render_target{})

// unpackArgSPKinc_g4_render_target transforms a sliced Go data structure into plain C format.
func unpackArgSPKinc_g4_render_target(x []*kinc_g4_render_target) (unpacked **C.struct_kinc_g4_render_target, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocPStruct_kinc_g4_render_targetMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]*C.struct_kinc_g4_render_target)(unsafe.Pointer(h0))
	for i0 := range x {
		v0[i0], _ = x[i0].PassRef()
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (**C.struct_kinc_g4_render_target)(h.Data)
	return
}

// packSPKinc_g4_render_target reads sliced Go data structure out from plain C format.
func packSPKinc_g4_render_target(v []*kinc_g4_render_target, ptr0 **C.struct_kinc_g4_render_target) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPtr]*C.struct_kinc_g4_render_target)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = Newkinc_g4_render_targetRef(unsafe.Pointer(ptr1))
	}
}

// copyPUintBytes copies the data from Go slice as *C.uint.
func copyPUintBytes(slice *sliceHeader) (*C.uint, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfUintValue) * slice.Len,
		Cap:  int(sizeOfUintValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.uint)(mem0), allocs
}

// allocUintMemory allocates memory for type C.uint in C.
// The caller is responsible for freeing the this memory via C.free.
func allocUintMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfUintValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfUintValue = unsafe.Sizeof([1]C.uint{})

// unpackArgSKinc_g4_render_target transforms a sliced Go data structure into plain C format.
func unpackArgSKinc_g4_render_target(x []kinc_g4_render_target) (unpacked *C.kinc_g4_render_target_t, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocKinc_g4_render_targetMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.kinc_g4_render_target_t)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.kinc_g4_render_target_t)(h.Data)
	return
}

// packSKinc_g4_render_target reads sliced Go data structure out from plain C format.
func packSKinc_g4_render_target(v []kinc_g4_render_target, ptr0 *C.kinc_g4_render_target_t) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfKinc_g4_render_targetValue]C.kinc_g4_render_target_t)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *Newkinc_g4_render_targetRef(unsafe.Pointer(&ptr1))
	}
}
